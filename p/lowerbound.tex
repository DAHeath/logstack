\section{Lower Bound}\label{sec:lowerbound}
\begin{theorem}
Consider a circuit with $b$ branches $\cir_1,..., \cir_b$.  Suppose
\Eval\ and \Gen\ each issue only
$O(b)$ calls to \Gb. If \Gen\ sends to \Eval\ the stacking of material from
the $b$ branches $\mat = \mat_1 \oplus ... \oplus \mat_b$, then \Gen\ must issue $\Omega(b^2)$  calls to \Ev.
\end{theorem}
\begin{proof}
Consider an arbitrary execution where $\cir_t$  is taken.
For correctness, \Eval\ must invoke \Ev\ on $\cir_t$; that is, she
must evaluate the taken branch.
To do so, \Eval\ must unstack from $\mat$ the material $\mat_t$,
requiring her to reconstruct all materials $\mat_{i\neq t}$.
Reconstructing these materials requires \Eval\ to call \Gb\ using the
same seeds as \Gen.
%
To begin, note the following facts:
\begin{itemize}
  \item
    The scheme must instruct \Eval\ to `attempt' to
    evaluate \emph{every} branch $\cir_i$. If not,
    \Eval\ can trivially observe that some branch is not taken.
    Specifically, any branch she does not evaluate must not be
    taken.
  \item
    Because \Eval\ must invoke \Gb\ on each non-taken branch for
    correctness, she must also invoke \Gb\ on the taken branch.
    If not, \Eval\ can observe that the branch that the
    scheme does not instruct her to garble must be taken.
  \item
    \Eval\ cannot reconstruct material $\mat_t$
    through an invocation of \Gb. If she could, she would
    see the wire encodings on the taken branch and could immediately
    decrypt the cleartext wire values.
    Instead, she must reconstruct some `incorrect' material $\mat_t'
    \neq \mat_t$ that does not compromise security.
\end{itemize}
Putting these facts together, we can informally see that
\Eval\ must evaluate all non-taken branches $\cir_{i\neq t}$ on some
material $\mat_i' \neq \mat_i$: she cannot successfully unstack $\mat_i$
from $\mat$ because she cannot reconstruct $\mat_t$ via \Gb.
%
We refer to such material as `incorrect': it is not the same material
as constructed by \Gen.
Material that \emph{is} in the XOR expression for $M$ is correspondingly called
`correct' material.

Evaluations on incorrect material lead to garbage output values that,
by the `garbage axiom', can only be eliminated by having \Gen\ invoke
\Ev.
At a high level, the following proof demonstrates that there are
necessarily $\Omega(b^2)$ possible garbage outputs that \Eval\ might
compute, and thus \Gen\ must invoke \Ev\ $\Omega(b^2)$ times to
predict all garbage outputs.

As stated above, \Eval\ invokes \Gb\ on each branch at least once, but beyond this the
scheme may instruct \Eval\ to garble each branch an arbitrary number of
times, so long as there are only $O(b)$ total garblings.
%
We refer to the collection of different materials for a single branch
as that branch's \emph{pool} of materials.
That is, a pool contains multiple materials, each for the same branch,
and at most one of which is correct (since $M$ contains only one
garbling of each branch, only one pool material can possibly be
correct).
%
To evaluate a given branch $\cir_i$, \Eval\ selects one element from
each pool except the pool corresponding to $\cir_i$, XORs these
elements with $\mat$ to attempt to extract $\mat_i$, and evaluates
$\cir_i$ on the unstacked material.
%
Informally, increasing the size of pools can help to reduce
the number of possible ways that \Eval\ might unstack incorrect
material, and hence reduces the number of possible garbage outputs.
%
We show that if the total combined size of all pools
is $O(b)$, the number of possible garbage outputs is $\Omega(b^2)$
(the total combined size of all pools cannot exceed $O(b)$,
because \Eval\ is limited to $O(b)$ invocations to \Gb).

%\Eval\ uses these garblings to
%unstack $b$ materials: one per `guessed' branch. That is, for each
%branch $\cir_j$, \Eval\ selects one garbling of every other branch
%$\cir_{k\neq j}$, XORs these garblings with the stacked material, and
%evaluates $\cir_j$ on the unstacked material. Recall that in the case
%of $\cir_t$,
%%
%\Eval\ must unstack using the $b-1$ `good' materials (or else the scheme
%is not correct). When a garbling is used to evaluate a branch in this
%manner, we henceforth simply say that the material is \emph{used}.
%Other than using all `good' materials to evaluate the taken branch, a
%priori there are no other restrictions on how these $O(b)$ garblings
%are used.
%%
%Said another way, each branch has a `pool' of garblings that are
%given, via seed, to \Eval. The garbling scheme instructs \Eval\ to
%XOR together $b-1$ of these garblings (one from each pool) to evaluate each
%branch.

\begin{itemize}
  \item \textbf{Claim 1.} At most a sub-linear number of pools have
    size greater than $O(1)$.
    \begin{subproof}
      Informally, this claim says that the pools of materials are
      generally small, and informally the claim holds because if they
      were `too large', then the number of materials would exceed the
      allowed number of calls to \Gb.

      More formally: by pigeonhole principle.
      If this were not the case, then there
      would be more than $O(b)$ total materials.
    \end{subproof}

  \item \textbf{Claim 2.}
    All pools with size $O(1)$ contain a material that is used to
    unstack $\Omega(b)$ times.
    \begin{subproof}
      Informally, since \Eval\ draws from each pool a `large number'
      (i.e., linear number) of times (once per evaluated branch),
      if a pool is `small', \Eval\ must choose at least one item  a
      large number of times.

      More formally: by Claim 1 and pigeonhole principle. To evaluate
      each guessed branch, \Eval\ unstacks using one material from every other
      branch.  Thus, \Eval\ uses $b-1$ total materials from each pool.
      If a pool has only $O(1)$ available materials, at least one
      must be chosen by \Eval\ $\Omega(b)$ times.
    \end{subproof}

  \item \textbf{Claim 3.} At most a sub-linear number of
    \emph{correct} materials are used only a sub-linear number of times.
  \begin{subproof}
    Recall that \Eval\ constructs via \Gb\ exactly $b-1$ correct
    materials: one per non-taken branch.
    Informally, we observe that if a large number
    of correct materials are used a small number of times, an
    adversarial evaluator can simply look at which materials are used
    a small number of times to help her determine which materials are
    correct.
    %
    This strategy gives the adversary a constant advantage in
    distinguishing which branch is taken because most pools (1) have
    one correct material, (2) have only constant elements, and (3) have
    at least element with `high usage'.
    %
    Determining which materials are correct gives information about
    which branch is taken, since only the taken branch unstacks using
    all of the correct materials.

    More formally: suppose not.
    That is, suppose that $\Omega(b)$ correct materials are used only a
    sub-linear number of times.
    That is, a constant fraction of correct materials are used only a
    sub-linear number of times.
    Then there exists a distinguisher with a non-negligible advantage
    in identifying the taken branch.
    Consider those pools with
    only $O(1)$ materials (by Claim 1, almost all pools have this
    property). By the pigeonhole principle, a constant fraction of
    these pools have a correct material used only a sub-linear
    number of times.
    % Consider one of these pools.
    Suppose the distinguisher uniformly draws one of these pools.
    By Claim 2, this pool has a material that is used $\Omega(b)$
    times, but our supposition this highly used material can be the
    correct one with only \emph{constant probability}.
    Thus, the distinguisher can guess that this highly used material
    is not correct, and guess that all branches that do use the
    material to unstack are not taken (a sensible strategy because the
    taken branch must use the correct material).
    %
    With \emph{constant probability} this guess will be correct,
    giving the distinguisher a constant advantage in distinguishing
    the taken branch.
    %
    Thus if $\Omega(b)$ correct materials are used only a
    sub-linear number of times, then the scheme cannot be secure.
    %The distinguisher
    %can uniformly sample from the sub-linearly used materials of this
    %branch, and guess that this material is the correct one.
    %%
    %Since one of the constant number of materials must be used
    %$\Omega(b)$ times (Claim 2), this gives the distinguisher a
    %constant advantage in distinguishing which material is correct.
    %%
    %Recall that the distinguisher wishes to guess which branch is
    %taken, and that the taken branch uses the correct material. If the
    %distinguisher rules out those branches that do not use the guessed
    %correct material, then it has a constant advantage in indeed ruling
    %out a non-taken branch.
  \end{subproof}
\end{itemize}

By Claim 3, all but a sub-linear number of correct
materials are used $\Omega(b)$ times. Thus, together the correct materials are used a
total of $\Omega(b^2)$ times. Equivalently, consider the evaluation of each
branch (each of which uses $b-1$ materials to unstack). Since each of these
evaluations uses only one material of each branch, $\Omega(b)$ evaluations
must use $\Omega(b)$ correct materials.  Call the execution we have thus far
considered $A$.
Now, consider a different execution where branch
$\cir_{s\neq t}$  is taken, and call this new execution $B$. Because
$\cir_s$ is
not taken in $A$, the correct material must be given to \Eval\ in $A$. Suppose
that this material is used $\Omega(b)$ times (By claim 3, almost all such
correct materials are). Now, for security, the correct material of $\cir_s$ is
not available to \Eval\ in $B$, because $\cir_s$ is taken in $B$. Thus, those
$\Omega(b)$ branches that were evaluated using the correct material of
$\cir_s$
in $A$
must be evaluated using a different material in $B$ (the correct
material
simply is not available). So, when \Eval\ evaluates these $\Omega(b)$ branches
in $A$ and when she evaluates the same branches in $B$, she will compute
different per-branch output labels. By extending this argument to
consider all pairs of possibly executed branches, there are $\Omega(b^2)$
possible output labels \Eval\ might compute. By the “evaluation axiom”,
\Gen\ can only eliminate output labels by precomputing them himself.
Thus, he must issue $\Omega(b^2)$ calls to \Ev.
\end{proof}


\begin{theorem}
Consider a circuit with $b$ branches.  Suppose \Gen\ issues only
$O(b)$ calls to \Ev. If \Gen\ sends to \Eval\ the stacking of material from
the $b$ branches, then \Gen\ must issue $O(b^2)$  calls to \Gb.
\end{theorem}
\begin{proof}

\textbf{Claim 1.} At most a sub-linear number of
`good' garblings are used only a sub-linear number of times.
  \begin{subproof}
    Suppose not.
    That is, suppose that $O(b)$ `good' garblings are used only a
    sub-linear number of times.
    Then there exists a distinguisher with a non-negligible advantage
    in identifying the taken branch.
    Consider those branches with
    only $O(1)$ garblings (by Claim 1, almost all branches have this
    property). By the pigeonhole principle, a constant fraction of
    these branches have a `good' garbling used only a sub-linear
    number of times. Consider one of these branches. The distinguisher
    can uniformly sample from the sub-linearly used garblings of this
    branch, and guess that this garbling is the `good' one. Since one
    of the constant number of garblings must be used $O(b)$ times
    (Claim 2), this gives the distinguisher a constant advantage in
    distinguishing which garbling is the `good' one. Recall that the
    distinguisher wishes to guess which branch is taken, and that the
    taken branch uses the `good' garbling. If the distinguisher rules
    out those branches that do not use the guessed `good' garbling,
    then it has a constant advantage in indeed ruling out a non-taken
    branch.

    Less formally, this proof observes the fact that if a large number
    of the `good' garblings are used a small number of times, an
    adversarial evaluator can simply look at which garblings are used
    only a small number of times to help her determine which seeds are
    good.
    %
    This strategy gives constant advantage because most pools (1) have
    one `good' garbling, (2) have only constant elements, and (3) have
    at least element with `high usage' (i.e., that is used to unstack
    $\Omega(b)$ times).
    %
    Determining which garblings are `good' gives information about which
    branch is taken, since only the taken branch uses all the `good'
    garblings.
  \end{subproof}
\end{proof}
