\section{Related Work}\label{sec:relwork}


GC is the most popular and often the fastest approach to secure two-party computation.  Until recently, it was believed that it is necessary
to transmit the entire GC during 2PC, even for inactive conditional
branches.
Recent breakthrough work~\HK showed that this folklore
belief is false, and that  it suffices to only transmit GC material  proportional to the
longest execution path. % rather than to the entire circuit.

We focus our comparison with prior work on~\HK, and then review other
related work, such as universal circuits and  earlier stacked garbling work.


\paragraph{Comparison with~\HK.} As discussed
in~\Cref{sec:motivationHighB}, programs with conditionals with high
branching factor may be a result of program transformations aimed at
optimizing GC/SGC performance.  While the protocol of~\HK is
concretely efficient, its quadratic computational cost presents a
limitation even in settings with  relatively  modest branching factor
$b$.  This significantly limits the scope of program transformations
which will be effective for SGC.


Our work achives total computational cost proportional to $3.5 b \log
b$, and  effectively removes the computational overhead of the SGC
technique as a constraining consideration\footnote{We stress that
branches must still be garbled, and extreme program transformations,
such as stacking {\em all} possible program control flows, may be
impractical computationally due to the exponential number of
branches.}, as discussed in~\Cref{sec:whentouse}. 

%Above we only discussed the garbling costs in terms of the number of circuits processed (i.e. garbled or evaluated).  
Memory management is a significant performance factor in GC
in general, and in particular in~\HK garbling.  Retrieving an
already-garbled material from RAM may take similar or longer time than
regarbling from scratch while operating in cache.
In addition to significantly improving computation (i.e. number
of calls to \Gb\ and \Ev), our approach offers improved
memory utilization (see~\Cref{sec:ourContrib,sec:memoryEfficiency}).
\HK requires that a linear number of
garbled circuits be kept in RAM.  For larger circuits this can become
a problem.
For example, the garbling of a $1$M AND-gate circuit
occupies $32$MB in RAM.
If a machine can dedicate $2$GB to garbling, a maximum of
$64$ branches of this size can be handled. This
ignores additional constant space costs, which are not necessarily
low.
%
In contrast, we use only $O(\log b)$ space, and hence can
fit the garblings of large numbers of branches into memory.
In our experiments, we ran our implementation on a circuit with $8192$
SHA-256 branches, a circuit that altogether holds $> 385$M AND-gates.
Our peak memory usage was at around $100$MB (\HK would require more
than $12$GB of space to run this experiment).

% For $16$ branches, this results in
% $16^2\cdot32$MB = $8,192$MB, surpassing RAM of a typical laptop and
% either crashing or drastically reducing performance due to disk
% swapping.  In contrast, our RAM consumption in the above setting is
% ??? MB. Even in the case of thousands or millions of branches of $1$M
% gates, we will be comfortably within standard laptop RAM sizes:
% \vlad{GIVE EXAMPLE}.   We discuss this aspect in technical detail
% in~\Cref{sec:memoryEfficiency}.

% This analysis is reflected in the charts presented in the Evaluation
% (\Cref{sec:evaluation}).   

In sum, as discussed at length
in~\Cref{sec:whentouse,sec:memoryEfficiency,sec:eval}, we
essentially eliminate the concern of increased computation due to
Stacked Garbling for typical settings 
%(1 Gbps network, commodity laptop computing device)
and open the door to the possibility of applying a large class of
efficiency-improving program transformations on the evaluated program.


\paragraph{Universal circuits.}
An alternate technique for handling conditional branching is to
implement a \emph{universal circuit} that can represent any branch in
the conditional.
We discuss universal circuits in more detail in Supplementary Material.
In short, SGC is a more practical approach to conditional branching in
most scenarios.

\paragraph{Other related work.}

%There is a small number of works that address branching in secure
%computation, but are not GC/constant-round 2PC.  

Kolesnikov~\cite{AC:Kolesnikov18} was the first to separate the GC
{\em material} from circuit topology.
This separation was used to improve GC branching
given that the GC generator \G knows the active branch.
Subsequently, \cite{EC:HeaKol20} considered a complementary setting
where the GC evaluator \E knows the active branch, and used it to
construct efficient ZK proofs for circuits with branching.  Our work
follows the line of work initiated
by~\cite{AC:Kolesnikov18,EC:HeaKol20}; it is for general 2PC and is
constant-round.

As discussed in~\HK, interaction, such as via the output
selection protocol of~\cite{AC:Kolesnikov18}, can be used to collect
garbage efficiently (computation linear in $b$).
However, a communication round is added for each conditional branch.
In many scenarios, non-interactive 2PC (such as what we achieve) is preferred.

Designing efficient garbling schemes under standard assumptions (i.e.
using only PRFs) is a valuable research direction.
\cite{CCS:GLNP15} impressively implement garbled table
generation and evaluation with speed similar to that of
fixed-key AES.
\cite{CCS:GLNP15} cannot use the Free XOR technique~\cite{ICALP:KolSch08}, which requires circularity
assumptions~\cite{TCC:CKKZ12}, but nevertheless implement XOR Gates
with only one garbled row and AND gates with two rows.
