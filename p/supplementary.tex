\section{Correctness/Security Proofs}\label{supp:proofs}

% \begin{theorem}\label{theorem:correctness}
%   If \underscheme\ is correct, then \ourschemelong\ is correct.
% \end{theorem}
The following proves \Cref{theorem:correctness}, i.e. \ourschemelong\
is correct:
\begin{proof}
  By induction on structure of $\cir$.
  \begin{itemize}
    \item Suppose \cir\ is a netlist. Then since \ourschemelong\ delegates
      to the correct scheme \underscheme, \ourschemelong\ is trivially
      correct.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction, both $\cir_0$ and $\cir_1$ correctly propagate
      input labels to output labels.
      Thus, to finish the proof, we must show that we appropriately
      translate output labels from $\cir_0$ to $\cir_1$. But this is
      the role of the translator component, which is trivially correct
      as it is implemented by garbled rows~\HK.
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      Consider an arbitrary execution where the branch $\cir_\act$ is
      active.
      %
      By definition, the first $\lceil \log |\vec \cir| \rceil$ input
      labels to \gEv\ are an encoding of \act.
      %
      Recall that \gGb\ constructs the material $M = \bigoplus_i
      \gcir_i$: this is the material available to \gEv.
      %
      Due to the correctness of \gadget, \gEv\ computes the correct
      sibling roots of $\cir_A$. Thus, \evcond\ reconstructs the correct
      garblings $\gcir_{i \neq A}$, XORs these with $M$, and hence
      extracts $\gcir_A$.

      Now, it remains to show two points.
      First, we must show that the inputs are correctly fed to
      $\cir_A$. The second is to show that the garbage values from all
      branches $\cir_{i \neq A}$ are collected.
      %
      The first point is handled by the demultiplexer.
      %
      The demultiplexer implements via garbled rows simple logic: the
      correct input is forwarded to $\cir_A$, and garbage labels (that
      are independent of the input) is forwarded to all other circuits
      $\cir_{i \neq A}$.
      %
      The second point is handled by the multiplexer, generated by the
      emulation of all possible garbage branch evaluations.
      %
      We refer the reader to \Cref{sec:techOverview} for an extensive
      discussion of how this emulation is achieved.
      %
      In short, we carefully arrange \gadget\ such that there are
      only $\lceil \log |\vec \cir| \rceil$ garbage evaluations
      possible per branch.
      %
      Because the number of garbage evaluations is small, it is easy
      for \gGb\ to compute all of these cases itself.
      %
      With all possible garbage output labels available, garbage
      collection becomes the straightforward implementation of garbled
      rows.
      %In particular, consider a single corresponding output wire
      %from each branch.
      %%
      %The multiplexer first XORs together these labels.
      %Now, it uses \act\ to construct garbled rows that hold all
      %possible garbage values for this wire.
      %Thus, depending on \act, \gEv\ will decrypt exactly the garbage
      %values that were XORed into the overall sum.
      %%
      %XORing these with the overall sum leaves only the valid output.
  \end{itemize}
  \ourschemelong\ is correct.
\end{proof}

The following proves \Cref{thm:strongstack}, i.e. \ourschemelong\ is
strongly stackable.
\begin{proof}
  By induction on the structure of \cir.
  We say `$x$ looks random' to denote that $x$ is indistinguishable from a uniform string of the same length.
  \begin{itemize}
    \item Suppose \cir\ is a netlist.
      Then $\ourschemelong$ delegates to \underscheme,
      which is assumed to be strongly stackable.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction,
      both $\cir_0$ and $\cir_1$ are strongly stackable.
      We demonstrate that the intervening translation
      gadget preserves strong stackability.
      %
      Consider a subcomponent of the translator that translates one wire.
      %
      This subcomponent is implemented as an encrypted truth table with two ciphertexts of material.
      %
      Each row is the XOR of an input label with the
      output
      of a PRF keyed at the $\lkey$ of a label specified by the
      decoding string $d_0$ of $\cir_0$.
      Since $\cir_0$ is strongly stackable, this key looks random.
      Hence, the output of the PRF looks random.
      Furthermore, correctly decrypting one row yields an
      input label for $\cir_1$ which, by induction, looks random.
      %
      Therefore, the ciphertexts constructed by $\gbtranslate$
      look random, so the translation gadget preserves strong stackability.
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      By induction, each branch $\cir_i \in \vec \cir$ is strongly
      stackable.
      Hence, the material from each branch looks random, and so the
      XOR stacking of all materials looks random as well.
      %
      It remains to show that \gadget, the demultiplexer, and the multiplexer
      preserve strong stackability.
      Like the translator (see discussion of sequences
      above), these gadgets are constructed using a PRF, and hence
      their material looks random.
      %
      An additional important detail is that \gadget\ outputs good
      seeds only for the sibling subroots of the active branch \aid.
      Recall that the good seed for each node in the binary branching
      tree is derived from its parent's seed, so it may seem there is
      a possibility that \E can check if seeds are related to one
      another.
      %
      However, because \gadget\ gives only good seeds corresponding to
      sibling roots of a fixed (active) branch, all seeds seen by \E\ are
      unrelated.
      %
      Finally, \E\ reconstructs, via seeds, the good garbling of each
      circuit $\cir_{i\neq\aid}$. Thus, she sees the input encoding
      for each branch $\cir_{i\neq\aid}$.
      %
      Thus, it may seem that \E\ can compare input encodings of
      each branch with that branch's input labels.
      %
      However, the demultiplexer computes, based on \aid, garbage inputs
      unrelated to each of these encodings, and hence the outputs of
      the demultiplexer and the garblings of each branch are
      unrelated.
  \end{itemize}
  Finally,
  all encodings directly handled our gadgets are either given to us by
  \underscheme, our are uniformly drawn (with appropriate color bits), and
  hence we satisfy properties 2 through 4.
  \ourschemelong\ is strongly stackable.
\end{proof}

The following proves \Cref{thm:authenticity}, i.e. \ourschemelong\ is
authentic.
\begin{proof}
  By induction on the structure of the circuit $\cir$.
  In each case, we proceed backwards across the components of $\cir$ (i.e. from outputs to inputs), at
  each step showing that $\adv$ cannot obtain valid labels
  except by running the previous components of the circuit.
  \begin{itemize}
    \item Suppose $\cir$ is a netlist. \ourschemelong delegates to
      \underscheme which is assumed authentic.
    \item Suppose $\cir$ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction, \adv\ cannot obtain valid
      output from $\cir_1$ except by running $\gEv$.
      %
      Furthermore, the intervening translator gadget is authentic: it
      is constructed by masking the translator output label with a PRF call
      keyed at the respective translator input label.
      %
      Thus, \adv\ cannot compute a translator output label without providing
      a corresponding input label from the output of $\cir_0$.
      %
      Finally, $\cir_0$ inductively preserves authenticity.
      %
      Thus, the sequence is authentic.
    \item Suppose $\cir$ is a conditional $\conditional(\vec{\cir})$.
      %
      First, we examine the mux. Using the same argument as for the
      translator (the mux is built using a PRF), valid output cannot be obtained except by running $\evmux$ on valid inputs.

      Inputs to the mux component are constructed by evaluating
      each branch $\cir_i$.
      %
      By induction $\cir_\aid$ is authentic, and so $\adv$ cannot
      obtain output labels from the active circuit without providing
      corresponding input labels.
      %
      Note, each circuit $\cir_{i \neq \aid}$ is not supported by our
      inductive argument, since we operate on these circuits with
      garbage labels and material.
      %
      However, because the output of the multiplexer is masked by a
      PRF call on outputs from \emph{each} branch, it suffices that
      $\cir_\aid$ is authentic.

      Finally, consider the demultiplexer and \gadget. $\adv$ cannot construct valid
      input to $\cir_\aid$ except by running these components: they
      are built using a PRF.
      %
      Thus, the overall conditional is authentic.
  \end{itemize}
  \ourscheme is authentic.
\end{proof}


The following proves \Cref{thm:privacy}, i.e. \ourschemelong\ is
private.
\begin{proof}
  By induction on the structure of $\cir$.
  \begin{itemize}
    \item Suppose \cir\ is a netlist. \ourschemelong\ delegates to
      \underscheme\ which is assumed private.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      Note that the garbling of $\cir_0$ is independent of
      $\cir_1$, and so the garbling of $\cir_0$ cannot give any extra information when combined
      with $d$ from $\cir_1$.
      %
      While the translator gadget is not independent of the garbling
      of $\cir_1$ (its garbled rows include labels from the input
      encoding of $\cir_1$), the information related to $\cir_1$ is
      masked by secure evaluation of a PRF.
      %
      Furthermore, because $\cir_0$ is authentic, there is no feasible
      way for \adv\ to compute any input to the translator which is
      not computed by evaluating $\cir_0$ on a given input.
      % way for \adv\ to compute input labels to the translator that cannot be
      % simulated.
      %
      Thus, the following simulator suffices:
      \begin{align*}
        &\simulator_{prv}(1^\kappa, \sequential(\cir_0, \cir_1), \cirout):\\
        &~~(\mat_0, \gcirinp_0) \gets \simulator_{obv}(1^\kappa, \cir_0)\\
        &~~\gcirout \gets \gEv(\cir_0, \mat_0, \gcirinp_0)\\
        &~~(\mat_1, \gcirinp_1, d) \gets \simulator_{prv}(1^\kappa, \cir_1, \cirout)\\
        &~~\mat_{tr} \gets \simulator_{tr}(\gcirout, \gcirinp_1)\\
        &~~\creturn~(\mat_0 \mid \mat_{tr} \mid \mat_1, \gcirinp_0, d)
      \end{align*}
      Where $\simulator_{tr}$ simulates a translator
      mapping the encoded output $\gcirout$ to the encoded input
      $\gcirinp_1$ (other rows that do not involve the labels in
      $\gcirinp_1$ are simulated by uniformly sampling strings).
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      % Note first that the garbling of each branch is independent from
      % the multiplexer, except that output labels from each branch are
      % used as PRF keys.
      In this case, the privacy simulator (1) garbles the conditional
      using a uniform seed, (2) encodes an arbitrary input (say, the
      all 0s input), and (3) evaluates the conditional.
      Now, the simulator holds material $\mat$, an encoded input
      $\gcirinp$, an output decoding $d$, and an encoded output
      $\gcirout$.
      The simulator conditionally swaps the labels in $d$ based on the
      output $\cirout$ such that $\gDe(d, \gcirout) = \cirout$ and
      outputs $(\mat, \gcirinp, d)$.
      Note, labels in $d$ are uniformly chosen by a call to
      $\genprojection$.
      Furthermore, the active branch $\cir_\aid$ is authentic, and
      hence there is no feasible way for \adv\ to compute any input to
      the multiplexer which is
      not computed by evaluating $\cir_\aid$ on a given input.
      %
      Thus, undecryptable multiplexer rows are securely simulated by
      random bits.
      % Thus, these labels are computationally indistinguishable from
      % uniform strings.
      $(\mat, \gcirinp, d)$ is indistinguishable from the real view.
  \end{itemize}
  \ourschemelong\ is private.
\end{proof}

