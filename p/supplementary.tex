\section{Efficiency Proofs}\label{supp:effproofs}

In this section, we prove lemmas regarding the efficiency of
$\gbtree$, $\evcond$, and $\gbcond$.
\Cref{thm:efficiency} follows as a corollary of these lemmas.

\subsubsection{\gbtree\ Efficiency.}

\begin{lemma}\label{lemma:gbtreetime}
  Let $\vec{\cir}$ be a vector of $b$ circuits,
  let $i, j \in \{0, b-1\}$ satisfy $i \leq j$,
  and let $seed \in \{0, 1\}^\kappa$ be an arbitrary string.
  Then $\gbtree(\vec \cir, i, j, seed)$ invokes $\ourscheme.\gGb$ $j - i + 1$ times.
\end{lemma}
\begin{proof}
  Immediate. The procedure only invokes $\ourscheme.\gGb$ at the base case.
\end{proof}
The algorithm garbles each branch only once.
Note that while \Cref{lemma:gbtreetime} (and also
\Cref{lemma:gbtreespace}) holds for all $i, j$, we are
only concerned with it holding for $i, j$ that represent valid nodes
in the binary tree of circuits.


\begin{lemma}\label{lemma:gbtreespace}
  Let $\vec{\cir}$ be a vector of $b$ circuits,
  let $i, j \in \{0, b-1\}$ satisfy $i \leq j$,
  and let $seed \in \{0, 1\}^\kappa$ be a arbitrary string.
  If $\ourscheme.\Gb$ runs in $O(\nmat)$ space,
  then $\gbtree(\vec \cir, i, j, seed)$ runs in $O(\nmat \log (j-i+1))$ space.
\end{lemma}
\begin{proof}
  In the base case, $\gbtree$ invokes $\ourscheme.\gb$. By assumption, this runs
  within our space requirement, and generates a garbling of maximum
  size $\nmat$.
  %
  In the general case, $\gbtree$ recursively invokes itself twice.
  After the first call has finished, we must store the
  intermediate result $M_L$.
  %
  Thus, at each recursive call site, we store a string of size
  $O(\nmat)$.
  Because each recursive call divides the range of considered circuits
  in half, the recursive tree has depth $O(\log(j-i+1))$.
  Hence, the total required storage is $O(\nmat \log(j-i+1))$.
\end{proof}



\subsubsection{\evcond\ Efficiency.}
In terms of time complexity, we start by examining the \emph{concrete}
efficiency on conditionals with $2^k$ branches for some $k$.
%
After, we discuss a generalization to arbitrary numbers of branches.

\begin{lemma}\label{lemma:evcondtime}
  Let $b = 2^k$ for some $k \in \mathbb{N}$.
  Let $\vec{\cir}$ be a vector of $b$ circuits, $\mat$ be a string of
  length $\nmat$, and $\gcirinp$ be a vector of labels of length
  $\inpsize(\conditional(\vec{\cir}))$.
  $\evcond(\vec{\cir}, \mat, \gcirinp)$ calls $\ourscheme.\gGb$ $b \log b$ times
  and calls $ourscheme.\gEv$ $b$ times.
\end{lemma}
\begin{proof}
  First, it is trivial that $\ourscheme.\gEv$ is called $b$ times: the
  procedure is called only at the base case, which is reached once per
  leaf.

  Second, \gbtree\ is called twice in the general case, each on a
  subtree of half of the current branches.
  %
  For example, at the root \gbtree\ is called on every branch, which, by
  \Cref{lemma:gbtreetime}, implies $b$ calls to $\ourscheme.\Gb$.
  Now consider a binary tree whose leaves are the $b$
  branches and whose internal nodes each correspond to
  a recursive invocation of $\evcond'$.
  At every level of the tree, each internal node garbles every
  leaf below it, via \gbtree.
  Hence, every level of the tree entails $b$ calls to $\ourscheme.\Gb$.
  Since the binary tree has $\log b$ levels, there are $b
  \log b$ total calls to $\ourscheme.\Gb$.
\end{proof}

By essentially exactly the same argument, one can prove the following
lemma for arbitrary numbers of branches:
\begin{lemma}\label{lemma:evcondtime-general}
  Let $\vec{\cir}$ be a vector of $b$ circuits, $\mat$ be a string of
  length $\nmat$, and $\gcirinp$ be a vector of labels of length
  $\inpsize(\conditional(\vec{\cir}))$.
  $\evcond(\vec{\cir}, \mat, \gcirinp)$ calls $\ourscheme.\gGb$ $O(b \log b)$ times
  and calls $\ourscheme.\gEv$ $b$ times.
\end{lemma}

The following lemma formalizes \evcond's logarithmic space complexity:
\begin{lemma}\label{lemma:evcondspace}
  Let $\vec{\cir}$ be a vector of $b$ circuits, $\mat$ be a string of
  length $\nmat$, and $\gcirinp$ be a vector of labels of length
  $\inpsize(\conditional(\vec{\cir}))$.
  $\evcond(\vec{\cir}, \mat, \gcirinp)$ runs in $O(\nmat \log b)$ space.
\end{lemma}
\begin{proof}
  Trivial, since no material is stored at recursive call sites.
  Thus the space complexity is inherited from
  \gbtree~(\Cref{lemma:gbtreespace}).
\end{proof}



\subsubsection{\gbcond\ Efficiency.}
As with \evcond, we start with a concrete claim
regarding conditionals with branching factors that are powers of two:

\begin{lemma}\label{lemma:gbcondtime}
  Let $b = 2^k$ for $k \in \mathbb{N}$.
  Let $\vec{\cir}$ be a vector of $b$ circuits and $S \in \{0,
  1\}^\kappa$ be a string.
  $\gbcond(\vec{\cir}, S)$ calls $\ourscheme.\gGb$ $\frac{3}{2}b \log b + b$ times and calls
  $\ourscheme.\gEv$ $b\log b$ times.
\end{lemma}
\begin{proof}
  First, we handle the $b$ $\ourscheme.\gGb$ calls. These $b$ calls arise from the
  top-level call to $\gbtree$ in $\gbcond$.
  The remaining $\frac{3}{2} b \log b$ calls come from
  \computegarbage.
  %
  Our argument is similar to that of \Cref{lemma:evcondtime}:
  at each level of the binary tree, $\computegarbage$ calls
  $\ourscheme.\gGb$ $\frac{3}{2}b$ times (via each node's three calls to \gbtree\
  on half of the node's ancestors).
  Since there are $\log b$ levels in the tree, $\computegarbage$ calls
  $\ourscheme.\gGb$ a total of $\frac{3}{2}b \log b$ times.

  All calls to $\ourscheme.\gEv$ arise from $\computegarbage$.
  In particular, $\ourscheme.\gEv$ calls occur in the base case (reached once per
  branch).
  Each branch is evaluated $\log b$ times: once per appropriate
  combination of garbage material. Since each leaf has $\log b$
  sibling roots, the vector $\vec{\mat}'$ has $\log b$ members.
  %
  Hence, we invoke $\ourscheme.\gEv$ a total of $b \log b$ times.
\end{proof}

By essentially the same argument, the following claims holds
for conditionals with arbitrary branching factors:
\begin{lemma}\label{lemma:gbcondtime-general}
  Let $\vec{\cir}$ be a vector of $b$ circuits and $S \in \{0,
  1\}^\kappa$ be a string.
  $\gbcond(\vec{\cir}, S)$ calls \gGb\ $O(b \log b)$ times and calls
  $\gEv$ $O(b\log b)$ times.
\end{lemma}

Finally, \gbcond\ runs in logarithmic space:
\begin{lemma}\label{lemma:gbcondspace}
  Let $\vec{\cir}$ be a vector of $b$ circuits and $S \in \{0, 1\}^\kappa$ be a string.
  If $\gGb$ runs in $O(\nmat)$ space, then
  $\gbcond(\vec{\cir}, S)$ runs in $O(\nmat \log b)$ space.
\end{lemma}
\begin{proof}
  Like $\evcond$, \gbcond\ consumes space due to calls to
  $\gbtree$. However, by \Cref{lemma:gbtreespace}, each of these calls
  runs in $O(\nmat \log b)$ space.
  %
  Additionally, \computegarbage\ maintains a vector of material
  $\vec{\mat}'$.
  However, this vector's size is bounded by the depth of the tree: we
  concatenate one material to the vector at each recursive call
  site.
  Hence, $\vec{\mat}'$ holds $O(\log b)$ elements and hence has
  $O(\nmat \log b)$ size.
\end{proof}

\section{Correctness/Security Proofs}\label{supp:proofs}

% \begin{theorem}\label{theorem:correctness}
%   If \underscheme\ is correct, then \ourschemelong\ is correct.
% \end{theorem}
The following proves \Cref{theorem:correctness}, i.e. \ourschemelong\
is correct:
\begin{proof}
  By induction on structure of $\cir$.
  \begin{itemize}
    \item Suppose \cir\ is a netlist. Then since \ourschemelong\ delegates
      to the correct scheme \underscheme, \ourschemelong\ is trivially
      correct.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction, both $\cir_0$ and $\cir_1$ correctly propagate
      input labels to output labels.
      Thus, to finish the proof, we must show that we appropriately
      translate output labels from $\cir_0$ to $\cir_1$. But this is
      the role of the translator component, which is trivially correct
      as it is implemented by garbled rows~\HK.
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      Consider an arbitrary execution where the branch $\cir_\act$ is
      active.
      %
      By definition, the first $\lceil \log |\vec \cir| \rceil$ input
      labels to \gEv\ are an encoding of \act.
      %
      Recall that \gGb\ constructs the material $M = \bigoplus_i
      \gcir_i$: this is the material available to \gEv.
      %
      Due to the correctness of \gadget, \gEv\ computes the correct
      sibling roots of $\cir_A$. Thus, \evcond\ reconstructs the correct
      garblings $\gcir_{i \neq A}$, XORs these with $M$, and hence
      extracts $\gcir_A$.

      Now, it remains to show two points.
      First, we must show that the inputs are correctly fed to
      $\cir_A$. The second is to show that the garbage values from all
      branches $\cir_{i \neq A}$ are collected.
      %
      The first point is handled by the demultiplexer.
      %
      The demultiplexer implements via garbled rows simple logic: the
      correct input is forwarded to $\cir_A$, and garbage labels (that
      are independent of the input) is forwarded to all other circuits
      $\cir_{i \neq A}$.
      %
      The second point is handled by the multiplexer, generated by the
      emulation of all possible garbage branch evaluations.
      %
      We refer the reader to \Cref{sec:techOverview} for an extensive
      discussion of how this emulation is achieved.
      %
      In short, we carefully arrange \gadget\ such that there are
      only $\lceil \log |\vec \cir| \rceil$ garbage evaluations
      possible per branch.
      %
      Because the number of garbage evaluations is small, it is easy
      for \gGb\ to compute all of these cases itself.
      %
      With all possible garbage output labels available, garbage
      collection becomes the straightforward implementation of garbled
      rows.
      %In particular, consider a single corresponding output wire
      %from each branch.
      %%
      %The multiplexer first XORs together these labels.
      %Now, it uses \act\ to construct garbled rows that hold all
      %possible garbage values for this wire.
      %Thus, depending on \act, \gEv\ will decrypt exactly the garbage
      %values that were XORed into the overall sum.
      %%
      %XORing these with the overall sum leaves only the valid output.
  \end{itemize}
  \ourschemelong\ is correct.
\end{proof}

The following proves \Cref{thm:strongstack}, i.e. \ourschemelong\ is
strongly stackable.
\begin{proof}
  By induction on the structure of \cir.
  We say `$x$ looks random' to denote that $x$ is indistinguishable from a uniform string of the same length.
  \begin{itemize}
    \item Suppose \cir\ is a netlist.
      Then $\ourschemelong$ delegates to \underscheme,
      which is assumed to be strongly stackable.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction,
      both $\cir_0$ and $\cir_1$ are strongly stackable.
      We demonstrate that the intervening translation
      gadget preserves strong stackability.
      %
      Consider a subcomponent of the translator that translates one wire.
      %
      This subcomponent is implemented as an encrypted truth table with two ciphertexts of material.
      %
      Each row is the XOR of an input label with the
      output
      of a PRF keyed at the $\lkey$ of a label specified by the
      decoding string $d_0$ of $\cir_0$.
      Since $\cir_0$ is strongly stackable, this key looks random.
      Hence, the output of the PRF looks random.
      Furthermore, correctly decrypting one row yields an
      input label for $\cir_1$ which, by induction, looks random.
      %
      Therefore, the ciphertexts constructed by $\gbtranslate$
      look random, so the translation gadget preserves strong stackability.
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      By induction, each branch $\cir_i \in \vec \cir$ is strongly
      stackable.
      Hence, the material from each branch looks random, and so the
      XOR stacking of all materials looks random as well.
      %
      It remains to show that \gadget, the demultiplexer, and the multiplexer
      preserve strong stackability.
      Like the translator (see discussion of sequences
      above), these gadgets are constructed using a PRF, and hence
      their material looks random.
      %
      An additional important detail is that \gadget\ outputs good
      seeds only for the sibling subroots of the active branch \aid.
      Recall that the good seed for each node in the binary
      tree is derived from its parent's seed, so it may seem there is
      a possibility that \E can check if seeds are related to one
      another.
      %
      However, because \gadget\ gives only good seeds corresponding to
      sibling roots of a fixed (active) branch, all seeds seen by \E\ are
      unrelated.
      %
      Finally, \E\ reconstructs, via seeds, the good garbling of each
      circuit $\cir_{i\neq\aid}$. Thus, she sees the input encoding
      for each branch $\cir_{i\neq\aid}$.
      %
      Thus, it may seem that \E\ can compare input encodings of
      each branch with that branch's input labels.
      %
      However, the demultiplexer computes, based on \aid, garbage inputs
      unrelated to each of these encodings, and hence the outputs of
      the demultiplexer and the garblings of each branch are
      unrelated.
  \end{itemize}
  Finally,
  all encodings directly handled our gadgets are either given to us by
  \underscheme, our are uniformly drawn (with appropriate color bits), and
  hence we satisfy properties 2 through 4.
  \ourschemelong\ is strongly stackable.
\end{proof}

The following proves \Cref{thm:authenticity}, i.e. \ourschemelong\ is
authentic.
\begin{proof}
  By induction on the structure of the circuit $\cir$.
  In each case, we proceed backwards across the components of $\cir$ (i.e. from outputs to inputs), at
  each step showing that $\adv$ cannot obtain valid labels
  except by running the previous components of the circuit.
  \begin{itemize}
    \item Suppose $\cir$ is a netlist. \ourschemelong delegates to
      \underscheme which is assumed authentic.
    \item Suppose $\cir$ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction, \adv\ cannot obtain valid
      output from $\cir_1$ except by running $\gEv$.
      %
      Furthermore, the intervening translator gadget is authentic: it
      is constructed by masking the translator output label with a PRF call
      keyed at the respective translator input label.
      %
      Thus, \adv\ cannot compute a translator output label without providing
      a corresponding input label from the output of $\cir_0$.
      %
      Finally, $\cir_0$ inductively preserves authenticity.
      %
      Thus, the sequence is authentic.
    \item Suppose $\cir$ is a conditional $\conditional(\vec{\cir})$.
      %
      First, we examine the mux. Using the same argument as for the
      translator (the mux is built using a PRF), valid output cannot be obtained except by running $\evmux$ on valid inputs.

      Inputs to the mux component are constructed by evaluating
      each branch $\cir_i$.
      %
      By induction $\cir_\aid$ is authentic, and so $\adv$ cannot
      obtain output labels from the active circuit without providing
      corresponding input labels.
      %
      Note, each circuit $\cir_{i \neq \aid}$ is not supported by our
      inductive argument, since we operate on these circuits with
      garbage labels and material.
      %
      However, because the output of the multiplexer is masked by a
      PRF call on outputs from \emph{each} branch, it suffices that
      $\cir_\aid$ is authentic.

      Finally, consider the demultiplexer and \gadget. $\adv$ cannot construct valid
      input to $\cir_\aid$ except by running these components: they
      are built using a PRF.
      %
      Thus, the overall conditional is authentic.
  \end{itemize}
  \ourscheme is authentic.
\end{proof}


The following proves \Cref{thm:privacy}, i.e. \ourschemelong\ is
private.
\begin{proof}
  By induction on the structure of $\cir$.
  \begin{itemize}
    \item Suppose \cir\ is a netlist. \ourschemelong\ delegates to
      \underscheme\ which is assumed private.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      Note that the garbling of $\cir_0$ is independent of
      $\cir_1$, and so the garbling of $\cir_0$ cannot give any extra information when combined
      with $d$ from $\cir_1$.
      %
      While the translator gadget is not independent of the garbling
      of $\cir_1$ (its garbled rows include labels from the input
      encoding of $\cir_1$), the information related to $\cir_1$ is
      masked by secure evaluation of a PRF.
      %
      Furthermore, because $\cir_0$ is authentic, there is no feasible
      way for \adv\ to compute any input to the translator which is
      not computed by evaluating $\cir_0$ on a given input.
      % way for \adv\ to compute input labels to the translator that cannot be
      % simulated.
      %
      Thus, the following simulator suffices:
      \begin{align*}
        &\simulator_{prv}(1^\kappa, \sequential(\cir_0, \cir_1), \cirout):\\
        &~~(\mat_0, \gcirinp_0) \gets \simulator_{obv}(1^\kappa, \cir_0)\\
        &~~\gcirout \gets \gEv(\cir_0, \mat_0, \gcirinp_0)\\
        &~~(\mat_1, \gcirinp_1, d) \gets \simulator_{prv}(1^\kappa, \cir_1, \cirout)\\
        &~~\mat_{tr} \gets \simulator_{tr}(\gcirout, \gcirinp_1)\\
        &~~\creturn~(\mat_0 \mid \mat_{tr} \mid \mat_1, \gcirinp_0, d)
      \end{align*}
      Where $\simulator_{tr}$ simulates a translator
      mapping the encoded output $\gcirout$ to the encoded input
      $\gcirinp_1$ (other rows that do not involve the labels in
      $\gcirinp_1$ are simulated by uniformly sampling strings).
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      % Note first that the garbling of each branch is independent from
      % the multiplexer, except that output labels from each branch are
      % used as PRF keys.
      In this case, the privacy simulator (1) garbles the conditional
      using a uniform seed, (2) encodes an arbitrary input (say, the
      all 0s input), and (3) evaluates the conditional.
      Now, the simulator holds material $\mat$, an encoded input
      $\gcirinp$, an output decoding $d$, and an encoded output
      $\gcirout$.
      The simulator conditionally swaps the labels in $d$ based on the
      output $\cirout$ such that $\gDe(d, \gcirout) = \cirout$ and
      outputs $(\mat, \gcirinp, d)$.
      Note, labels in $d$ are uniformly chosen by a call to
      $\genprojection$.
      Furthermore, the active branch $\cir_\aid$ is authentic, and
      hence there is no feasible way for \adv\ to compute any input to
      the multiplexer which is
      not computed by evaluating $\cir_\aid$ on a given input.
      %
      Thus, undecryptable multiplexer rows are securely simulated by
      random bits.
      % Thus, these labels are computationally indistinguishable from
      % uniform strings.
      $(\mat, \gcirinp, d)$ is indistinguishable from the real view.
  \end{itemize}
  \ourschemelong\ is private.
\end{proof}

\section{Universal Circuits}
We use cryptographic techniques to reduce the cost of conditionals.
Our focus is the reduction of communication to that corresponding to
the longest branch (SGC), while keeping the computational cost low.
A related direction attempts to instead reduce such 2PC cost by
choosing alternate Boolean circuit representations.  Universal
circuits (UCs) can be \emph{programmed} to implement any circuit in
the entire universe of circuits of a given size
$n$~\cite{STOC:Valiant76}.  Researchers continue to search for smaller
UC constructions; recent work achieves size $\approx 4.5 |C| \log
|C|$~\cite{EPRINT:LipMohSad16,EC:KisSch16,AC:GunKisSch17,EPRINT:ZYZL19,EPRINT:AGKS19}.
%
UCs implement conditionals by programming the UC to be the taken
branch.  When the GC generator knows the evaluated branch, the cost of
UC programming is free as the generator directly programs the UC;
otherwise programming can be achieved by transferring the right
garbled table via OT, as, e.g., proposed in~\cite{AC:KenKolWil17}.
This causes further $\approx 5\times$ overhead.

There are several shortcomings of this approach.  Firstly,  $5\cdot
4.5 |C| \log |C|$ %(and even $4.5 |C| \log |C|$ cost of the free
programming case) is a significant {\em communication} cost, compared
to our cost $|C|$.  For example, even for branches with only $2^{10}$
gates, the UC is $5 \cdot 4.5 \cdot 10 = 225$ times larger than a
single branch.  For typical conditionals it is often much cheaper to
separately encrypt and send each branch.  Further, general branching
implementation for GC proposed in~\cite{AC:KenKolWil17} is not
constant-round, and requires a round of communiction for every
sequential conditional.


Focusing specifically on branching,~\cite{AC:KenKolWil17} proposed a
generalization of UCs called \emph{set} universal circuits ($\cal
S$-UCs).  An $\cal S$-UC implements a fixed set of circuits $\cal S$
rather than an entire size-$n$ universe.  \cite{AC:KenKolWil17}
focuses on the special case where $|\cal S|$ is small, capturing the
case where $\cal S$ is a set of conditional branches.  Their approach
applies heuristics to embed $\cal S$ into one programmable circuit.
\cite{AC:KenKolWil17} reports the performance of this heuristic for
specific sets of circuits, achieving up to $6\times$ GC size reduction
for $32$ branches.  However, some sets did not improve over their
original representations.  Our work always achieves size reduction to
that of the single (largest) branch. In the~\cite{AC:KenKolWil17}
example, we achieve up to $32\times$ GC size reduction for $32$
branches and requires no per-gate overhead, which is significant
in~\cite{AC:KenKolWil17} (about $22$ garbled rows per gate).  

