\section{Correctness/Security Proofs}\label{sec:proof}

We now prove the relevant properties of \ourschemelong, in particular
showing that it is correct and secure.
We formalize our theorems in the~\cite{CCS:BelHoaRog12} framework,
which requires a candidate garbling scheme to be \textbf{correct},
\textbf{oblivious}, \textbf{private}, and \textbf{authentic}.
This section shows that \ourschemelong\ satisfies these properties.

In addition, \HK\ introduced a new property, \textbf{stackability}, which
formalizes the class of garbling schemes whose garblings can be
securely stacked; hence stackable schemes are candidate underlying
schemes.
%
In this work, we strengthen the definition of stackability.  This
strengthening, which we call \textbf{strong stackability}, allows us to
prove security under standard assumptions (an improvement over \HK,
which required a random oracle assumption).
Strong stackability is strictly stronger than stackability; all
strongly
stackable schemes are stackable,
and all lemmas that hold for stackable schemes hold also for strongly
stackable schemes.
A key application of this second fact is that all stackable schemes
are trivially \textbf{oblivious}, so all strongly stackable schemes are
also oblivious.
We prove security given a strongly stackable scheme.

\HK\ showed that standard garbling schemes are stackable, including
the state-of-the-art half-gates technique~\cite{EC:ZahRosEva15}.
We further argue that such schemes either are strongly stackable without
modification or can be easily adjusted.
Hence, our implementation can assume a RO and use half-gates as its underlying
scheme to achieve high performance.

We also show that \ourschemelong\ is itself strongly stackable, giving
flexibility in usage: while by design \ourschemelong\ handles vectors
of conditional branches, we also support arbitrarily nested
conditional control flow without modifying the source program.
%
We note that this nested usage \emph{does not} give $O(b\log b)$
computation, and so vectorized branches should favored where possible.
% Because \ourschemelong\ is strongly stackable, it is trivially
% \textbf{oblivious}~\HK,
% and so we do not discuss obliviousness further.



\subsection{Correctness}\label{sec:correctness}

\begin{definition}[Correctness]\label{def:correct}
  A garbling scheme is \textbf{correct} if for
  all circuits $\cir$,
  all input strings $\cirinp$ of length $\inpsize(\cir)$,
  and all pseudorandom seeds $S$:
  \[
    \gDe(d, \gEv(\cir, \mat,\gEn(e,\cirinp))) = \gev(\cir,\cirinp)
  \]
  where $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$
\end{definition}

That is, a correct scheme implements the semantics specified by \gev.

\begin{theorem}\label{theorem:correctness}
  If \underscheme\ is correct, then \ourschemelong\ is correct.
\end{theorem}
\begin{proof}
  By induction on structure of $\cir$.
  \begin{itemize}
    \item Suppose \cir\ is a netlist. Then since \ourschemelong\ delegates
      to the correct scheme \underscheme, \ourschemelong\ is trivially
      correct.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction, both $\cir_0$ and $\cir_1$ correctly propagate
      input labels to output labels.
      Thus, to finish the proof, we must show that we appropriately
      translate output labels from $\cir_0$ to $\cir_1$. But this is
      the role of the translator component, which is trivially correct
      as it is implemented by garbled rows~\HK.
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      Consider an arbitrary execution where the branch $\cir_\act$ is
      active.
      %
      By definition, the first $\lceil \log |\vec \cir| \rceil$ input
      labels to \gEv\ are an encoding of \act.
      %
      Recall that \gGb\ constructs the material $M = \bigoplus_i
      \gcir_i$: this is the material available to \gEv.
      %
      Due to the correctness of \gadget, \gEv\ computes the correct
      sibling roots of $\cir_A$. Thus, \evcond\ reconstructs the correct
      garblings $\gcir_{i \neq A}$, XORs these with $M$, and hence
      extracts $\gcir_A$.

      Now, it remains to show two points.
      First, we must show that the inputs are correctly fed to
      $\cir_A$. The second is to show that the garbage values from all
      branches $\cir_{i \neq A}$ are collected.
      %
      The first point is handled by the demultiplexer.
      %
      The demultiplexer implements via garbled rows simple logic: the
      correct input is forwarded to $\cir_A$, and garbage labels (that
      are independent of the input) is forwarded to all other circuits
      $\cir_{i \neq A}$.
      %
      The second point is handled by the multiplexer, generated by the
      emulation of all possible garbage branch evaluations.
      %
      We refer the reader to \Cref{sec:techOverview} for an extensive
      discussion of how this emulation is achieved.
      %
      In short, we carefully arrange \gadget\ such that there are
      only $\lceil \log |\vec \cir| \rceil$ garbage evaluations
      possible per branch.
      %
      Because the number of garbage evaluations is small, it is easy
      for \gGb\ to compute all of these cases itself.
      %
      With all possible garbage output labels available, garbage
      collection becomes the straightforward implementation of garbled
      rows.
      %In particular, consider a single corresponding output wire
      %from each branch.
      %%
      %The multiplexer first XORs together these labels.
      %Now, it uses \act\ to construct garbled rows that hold all
      %possible garbage values for this wire.
      %Thus, depending on \act, \gEv\ will decrypt exactly the garbage
      %values that were XORed into the overall sum.
      %%
      %XORing these with the overall sum leaves only the valid output.
  \end{itemize}
  \ourschemelong\ is correct.
\end{proof}

\subsection{Security}

The following definition is derived from the corresponding definition
of~\HK; we discuss its motivation (support for PRF-based garbling
gadgets) and technical differences with \HK immediately after we
present it formally below.

\begin{definition}[Strong Stackability]\label{def:stackable}
  A garbling scheme is \textbf{strongly stackable} if:
  \begin{enumerate}
    \item
      For
      all circuits $\cir$
      and all inputs $\cirinp$,
      \[
        (\cir, \mat, \gEn(e, \cirinp)) \indist (\cir, \mat', \gcirinp')
      \]
      where
      $S$ is uniformly drawn,
      $(\mat, e, \cdot) = \gGb(1^\kappa, \cir, S)$,
      $\gcirinp' \drawnfrom{} \{0, 1\}^{|\gcirinp|}$,
      and $\mat' \drawnfrom{} \{0, 1\}^{|\mat|}$.
    \item
      The scheme is \textbf{projective}~\cite{CCS:BelHoaRog12}.
    \item
      There exists an efficient deterministic procedure $\lcolor$ that
      maps strings to $\{0, 1\}$ such that for all \cir\ and all
      projective label pairs $A^0, A^1 \in d$:
      \[
        \lcolor(A^0) \neq \lcolor(A^1)
      \]
      where $S$ is uniformly drawn and $(\cdot, \cdot, d) \gets \gGb(1^\kappa, \cir\ S)$.
    \item
      There exists an efficient deterministic procedure $\lkey$ that
      maps strings to $\{0, 1\}^\kappa$ such that for all \cir\ and all
      projective label pairs $A^0, A^1 \in d$:
      \[
        \lkey(A^0) \mid \lkey(A^1) \indist \{0, 1\}^{2\kappa}
      \]
      where $S$ is uniformly drawn and $(\cdot, \cdot, d) \gets \gGb(1^\kappa, \cir\ S)$.
  \end{enumerate}
\end{definition}

The above definition is given by \HK, with the exception of point 4.
Informally, stackability ensures that (1) circuit garblings `look
random' and (2) our scheme can manipulate labels generated by the
underlying scheme.
Since strong stackability simply adds point 4, the following lemma is
immediate:
\begin{lemma}\label{lemma:stack-strongstack}
  Every strongly stackable scheme is stackable.
\end{lemma}

We briefly explain the role of \lcolor\ and \lkey. As with \HK, we
use the output labels of the underlying scheme as keys in subsequent
garbled gadgets.  The \lkey\ procedure allows us to extract a
\emph{suitable PRF key} from each label. At the same time, we make use
of the classic point-and-permute trick to reduce the number of PRF calls
needed to evaluate garbled gadgets: we use the \lcolor\ as the bit
that instructs which garbled rows to decrypt.  Note that because we
essentially `split’ each output label into a key and a color, we
`lose’ bits of the underlying scheme’s labels when we invoke
\lkey. We stress that this is not an issue: the required key
length for the next PRF application can be restored as we require
\lkey\ output to be $\kappa$ bits long. All point-and-permute schemes
have a similar approach.

The added requirement (point 4) allows us to relax
our security assumptions in comparison to \HK. In particular, for
each projective output pair $A^0, A^1$, we require that $\lkey(A^0)$ and
$\lkey(A^1)$ are unrelated.
This is achieved by requiring that the concatenation of these two
strings is indistinguishable from a random string of the same length.
This allows us to circumvent a problem: the \HK definition allowed labels in the underlying
scheme to be arbitrarily related.
More precisely, while point 1 requires that any particular set of labels seen by
\E\ look random, it does not require that \emph{all labels together}
look random.
%
This was problematic, because the output labels of the
underlying scheme were used to implement garbled tables, meaning that
the two possibly related labels were both used as PRF keys.
%
Of course, using related PRF keys is outside the scope of the standard
PRF security definition.
%
Thus, \HK were forced to assume the existence of a random oracle in
order to ensure possible relationships in the output decoding string
did not compromise security.
%
However, by adding point 2, we ensure that the \emph{entire} decoding
string `looks random', and hence all labels must be independent.
This added requirement on the underlying scheme allows us to push our
proofs through in the standard model.


Standard schemes are compatible with strong stackability:
if the scheme is stackable and has randomly chosen output labels, it
trivially satisfies our definition.
%
Free XOR based schemes~\cite{ICALP:KolSch08} assume that all
pairs of labels are separated by a fixed constant $\Delta$, and so
are not a priori strongly stackable. However, it is easy to adjust such
schemes such that the final output gates return independent labels.
%
As a final note, while our scheme is secure in the standard model, we
of course adopt any additional security assumptions from the chosen
underlying scheme: e.g., instantiating \ourschemelong\ with the efficient
Half Gates scheme~\cite{EPRINT:ZahRosEva14} requires us to assume the
existence of a correlation robust hash function.

\begin{theorem}\label{thm:strongstack}
  If \underscheme\ is strongly stackable, then \ourschemelong\ is strongly stackable.
\end{theorem}
\begin{proof}
  By induction on the structure of \cir.
  We say `$x$ looks random' to denote that $x$ is indistinguishable from a uniform string of the same length.
  \begin{itemize}
    \item Suppose \cir\ is a netlist.
      Then $\ourschemelong$ delegates to \underscheme,
      which is assumed to be strongly stackable.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction,
      both $\cir_0$ and $\cir_1$ are strongly stackable.
      We demonstrate that the intervening translation
      gadget preserves strong stackability.
      %
      Consider a subcomponent of the translator that translates one wire.
      %
      This subcomponent is implemented as an encrypted truth table with two ciphertexts of material (\Cref{sec:translate}).
      %
      Each row is the XOR of an input label with the
      output of $F_k(0)$ where $F$ is a PRF family and $k$ is \lkey\ of a label specified by the
      decoding string of $\cir_0$.
      Since $\cir_0$ is strongly stackable, this key looks random.
      Hence, the output $F_k(0)$ looks random.
      Furthermore, correctly decrypting one row yields an
      input label for $\cir_1$ which, by induction, looks random.
      %
      Therefore, the ciphertexts constructed by $\gbtranslate$
      look random, so the translation gadget preserves strong stackability.
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      By induction, each branch $\cir_i \in \vec \cir$ is strongly
      stackable.
      Hence, the material from each branch looks random, and so the
      XOR stacking of all materials looks random as well.
      %
      It remains to show that \gadget, the demultiplexer, and the multiplexer
      preserve stackability.
      Like the translator (see discussion of sequences
      above), these gadgets are constructed using a PRF, and hence
      their material looks random.
      %
      An additional important detail is that \gadget\ outputs good
      seeds only for the sibling subroots of the active branch \aid.
      Recall that the good seed for each node in the binary branching
      tree is derived from its parent's seed, so it may seem there is
      a possibility that \E can check if seeds are related to one
      another.
      %
      However, because \gadget\ gives only good seeds corresponding to
      sibling roots of a fixed branch, all seeds seen by \E\ are
      unrelated.
      %
      Finally, \E\ reconstructs, via seeds, the good garbling of each
      circuit $\cir_{i\neq\aid}$. Thus, she sees the input encoding
      for each branch $\cir_{i\neq\aid}$.
      %
      Thus, it may seem that \E\ can compare input encodings for
      branches with that branches input labels.
      %
      However, the demultiplexer computes, based on \aid, garbage inputs
      unrelated to each of these encodings, and hence the outputs of
      the demultiplexer and the garblings of each branch are
      unrelated.
  \end{itemize}
  \ourschemelong\ is strongly stackable.
\end{proof}

\begin{definition}[Obliviousness]\label{def:obliviousness}
  A garbling scheme is \textbf{oblivious} if there exists a
  simulator $\simulator_{obv}$ such that for
  any circuit $\cir$
  and all inputs $\cirinp$ of length $n$,
  the following are indistinguishable:
  \[
    (\cir, \mat, \gcirinp) \indist \simulator_{obv}(1^\kappa, \cir)
  \]
  where
   $S$ is uniform,
   $(\mat, e, \cdot) = \gGb(1^\kappa,\cir,S)$
  and $\gcirinp = \gEn(e,\cirinp)$.
\end{definition}

Obliviousness ensures that the garbled circuit can be simulated, and
hence reveals no extra information to \E.
\HK\ proved that every stackable scheme is trivially oblivious:
drawing a random string of the correct length is a suitable simulator.
This fact, combined with \Cref{lemma:stack-strongstack} and
\Cref{thm:strongstack} implies two
immediate facts:
\begin{lemma}\label{lemma:obliviousness}
  Every strongly stackable scheme is oblivious.
\end{lemma}
\begin{theorem}\label{thm:oblivious}
  If \underscheme\ is strongly stackable, \ourschemelong\ is oblivious.
\end{theorem}

\begin{definition}[Authenticity]\label{def:authenticity}
  A garbling scheme is \textbf{authentic} if for
  all circuits \cir,
  all inputs $\cirinp$ of length $n$,
  and all poly-time adversaries \adv 
  the following probability is negligible in $\kappa$:
  \[
    \pr{\gcirout' \neq \gEv(\cir, \mat,\gcirinp)
    \land
    \gDe(d, \gcirout') \neq \bot}
  \]
  where
  $S$ is uniform,
  $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$,
  $\gcirinp = \gEn(e,\cirinp)$,
  and $\gcirout' = \adv(\cir, \mat, \gcirinp)$
\end{definition}

\begin{theorem}\label{thm:authenticity}
  If \underscheme\ is authentic, then \ourschemelong\ is authentic.
\end{theorem}
\begin{proof}
\end{proof}

\begin{definition}[Privacy]\label{def:privacy}
  A garbling scheme is \textbf{private} if
  there exists a simulator $\simulator_{prv}$ such that for
  any circuit $\cir$
  and all inputs $\cirinp$ of length $n$,
  the following are computationally indistinguishable:
   \[
  (\mat, \gcirinp, d)
  \indist
  \simulator_{prv}(1^\kappa, \cir, \cirout),
  \]
  where
  $S$ is uniform,
   $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$,
  $\gcirinp = \gEn(e,\cirinp)$,
  and $\cirout = \gev(\cir,\cirinp)$. 
\end{definition}

\begin{theorem}
  If \underscheme\ is private and strongly stackable, then
  \ourschemelong\ is private.
\end{theorem}
\begin{proof}
  By induction on structure of $\cir$.
  \begin{itemize}
    \item Suppose \cir\ is a netlist. Then \ourschemelong\ delegates to
      \underscheme\ which is assumed private.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      Note that the garbling of $\cir_0$ is independent of
      $\cir_1$, and so the garbling of $\cir_0$ cannot give any extra information when combined
      with $d$ from $\cir_1$.
      %
      While the translator gadget is not independent of the garbling
      of $\cir_1$ (its garbled rows include labels from the input
      encoding of $\cir_1$), the information related to $\cir_1$ is
      masked by secure evaluation of a PRF.
      %
      Thus, the following simulator suffices:
      \begin{align*}
        &\simulator_{prv}(1^\kappa, \sequential(\cir_0, \cir_1), \cirout):\\
        &~~(\mat_0, \gcirinp_0) \gets \simulator_{obv}(1^\kappa, \cir_0)\\
        &~~\gcirout \gets \gEv(\cir_0, \mat_0, \gcirinp_0)\\
        &~~(\mat_1, \gcirinp_1, d) \gets \simulator_{prv}(1^\kappa, \cir_1, \cirout)\\
        &~~\mat_{tr} \gets \simulator_{tr}(\gcirout, \gcirinp_1)\\
        &~~\creturn~(\mat_0 \mid \mat_{tr} \mid \mat_1, \gcirinp_0, d)
      \end{align*}
      Where $\simulator_{tr}$ simulates a translator
      mapping the encoded output $\gcirout$ to the encoded input
      $\gcirinp_1$ (other rows that do not involve the labels in
      $\gcirinp_1$ are simulated by uniformly sampling strings).
    \item Suppose \cir\ is a conditional $\conditional(\vec \cir)$.
      % Note first that the garbling of each branch is independent from
      % the multiplexer, except that output labels from each branch are
      % used as PRF keys.
      In this case, the privacy simulator (1) garbles the conditional
      using a uniform seed, (2) encodes an arbitrary input (say, the
      all 0s input), and (3) evaluates the conditional.
      Now, the simulator holds material $\mat$, an encoded input
      $\gcirinp$, an output decoding $d$, and an encoded output
      $\gcirout$.
      The simulator conditionally swaps the labels in $d$ based on the
      output $\cirout$ such that $\gDe(d, \gcirout) = \cirout$ and
      outputs $(\mat, \gcirinp, d)$.
      Note, labels in $d$ are chosen by the secure evaluation of a PRF
      when constructing the final layer of garbled rows in the multiplexer.
      Thus, these labels are computationally indistinguishable from
      uniform strings.
      Thus, this view is indistinguishable from the real view.
  \end{itemize}
  \ourschemelong\ is private.
\end{proof}

