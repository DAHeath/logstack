\section{Proofs}\label{sec:proof}

\begin{definition}[Stackability]\label{def:stackable}
  A garbling scheme is \textbf{stackable} if:
  \begin{enumerate}
    \item
      For
      all circuits $\cir$
      and all inputs $\cirinp$,
      \[
        (\cir, \mat, \gEn(e, \cirinp)) \indist (\cir, \mat', \gcirinp')
      \]
      where
      $S$ is uniformly drawn,
      $(\mat, e, \cdot) = \gGb(1^\kappa, \cir, S)$,
      $\gcirinp' \drawnfrom{} \{0, 1\}^{|\gcirinp|}$,
      and $\mat' \drawnfrom{} \{0, 1\}^{|\mat|}$.
    \item
      For all circuits $\cir$,
      \[
        d \indist d'
      \]
      where
      $S$ is uniform, $(\cdot, \cdot, d) \gets \gGb(1^\kappa, \cir,
      S$),
      and $d' \drawnfrom{} \{0, 1\}^{|d|}$.
    \item
      The scheme is \textbf{projective}~\cite{CCS:BelHoaRog12}.
    \item
      There exists an efficient deterministic procedure $\lcolor$ that maps strings to $\{0, 1\}$ such that for all projective label pairs $A^0, A^1$
      \[
        \lcolor(A^0) \neq \lcolor(A^1)
      \]
  \end{enumerate}
\end{definition}

The above definition is given by \HK, with the exception of point 2.
Informally, stackability ensures that (1) circuit garblings `look
random' and (2) our scheme can manipulate labels generated by the
underlying scheme.

The added requirement to the definition (point 2) allows us to relax
our security assumptions in comparison to \HK. In particular, we require that the output decoding
strings $d$ be indistinguishable from a random string of the same
length.  This allows us to circumvent a problem: the \HK definition allowed labels in the underlying
scheme to be arbitrarily related to one another.
More precisely, while point 1 requires any particular labels seen by
\E\ look random, it does not require that \emph{all labels together}
look random.
%
This was problematic, because the output labels of the
underlying scheme were used to implement garbled tables.
%
Thus, \HK were forced to assume the existence of a random oracle in
order to ensure possible relationships in the output decoding string
did not compromise security.
%
However, by adding point 2, we ensure that the \emph{entire} decoding
string `looks random', and hence all labels must be independent.
This added requirement on the underlying scheme allows us to push our
proofs through in the standard model.

We note that all standard schemes can easily meet point 2:
if the scheme has randomly chosen labels, it trivially satisfies this
point.
%
Free XOR based schemes~(\cite{ICALP:KolSch08}) assume that all
pairs of labels are separated by a fixed constant $\Delta$, and so
they do not a priori meet point 2. However, it is easy to adjust such
schemes such that the final output gates return uncorrelated labels.
%
As a final note, while our scheme is secure in the standard model, we
of course adopt any additional security assumptions from the chosen
underlying scheme: e.g., isntantiating \ourscheme\ with the efficient
Half Gates scheme~\cite{EPRINT:ZahRosEva14} requires us to assume the
existence of a correlation robust hash function.
