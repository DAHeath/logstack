\section{Proofs}\label{sec:proof}

We now prove the relevant properties of \ourscheme, in particular
showing that it is correct and secure.
We formalize our theorems in the~\cite{CCS:BelHoaRog12} framework,
which requires a candidate garbling scheme to be \textbf{correct},
\textbf{oblivious}, \textbf{private}, and \textbf{authentic}.
This section shows that \ourscheme\ satisfies these properties.

In addition, \HK\ introduced a new property, \textbf{stackability}, which
formalizes the class of garbling schemes whose garblings can be
securely stacked; hence stackable schemes are candidate underlying
schemes.
%
In this work, we strengthen the definition of stackability.  This
strengthening, which we call \textbf{strong stackability}, allows us to
prove security under standard assumptions (an improvement over \HK,
which required a random oracle assumption).
Strong stackability is strictly stronger than stackability; all strong
stackable schemes are stackable,
and all lemmas that hold for stackable schemes hold also for strong
stackable schemes.
A key application of this second fact is that all stackable schemes
are trivially \textbf{oblivious}, so all strong stackable schemes are
also oblivious.
We prove security given a strong stackable scheme.

\HK\ showed that standard garbling schemes are stackable, including
the state-of-the-art half-gates technique~\cite{EC:ZahRosEva15}.
We further argue that such schemes either are strong stackable without
modification or can be easily adjusted.
Hence, our implementation can securely use half-gates as its underlying
scheme to achieve high performance.

We also show that \ourscheme\ is itself strong stackable, giving
flexibility in usage: while by design \ourscheme\ handles vectors
of conditional branches, we also support arbitrarily nested
conditional control flow without modifying the source program.
%
We note that this nested usage \emph{does not} give $O(b\log b)$
computation, and so vectorized branches should favored where possible.
Because \ourscheme\ is strong stackable, it is trivially
\textbf{oblivious}~\HK,
and so we do not discuss obliviousness further.



\subsection{Correctness}\label{sec:correctness}

\begin{definition}[Correctness]\label{def:correct}
  A garbling scheme is \textbf{correct} if for
  all circuits $\cir$,
  all input strings $\cirinp$ of length $n$,
  and all pseudorandom seeds $S$:
  \[
    \gDe(d, \gEv(\cir, \mat,\gEn(e,\cirinp))) = \gev(\cir,\cirinp)
  \]
  where $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$
\end{definition}

That is, a correct scheme implements the semantics specified by \gev.

\begin{theorem}\label{theorem:correctness}
  If \underscheme\ is correct, then \ourscheme\ is correct.
\end{theorem}
\begin{proof}
  By induction on structure of the circuit $\cir$.
  \begin{itemize}
    \item Suppose \cir\ is a netlist. Then since \ourscheme\ delegates
      to the correct scheme \underscheme, \ourscheme\ is trivially
      correct.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction, both $\cir_0$ and $\cir_1$ correctly propagate
      input labels to output labels.
      Thus, to finish the proof, we must show that we appropriately
      translate output labels from $\cir_0$ to $\cir_1$. But this is
      the role of the translator component, which is trivially correct
      as it is implemented by garbled rows~\HK.
    \item Suppose \cir\ is the conditional $\conditional(\vec \cir)$.
      Consider an arbitrary execution where the branch $\cir_\act$ is
      active.
      %
      By definition, the first $\lceil \log |\vec \cir| \rceil$ input
      labels to \gEv\ are an encoding of \act.
      %
      Recall that \gGb\ constructs the material $M = \bigoplus_i
      \gcir_i$: this is the material available to \gEv.
      %
      Due to the correctness of \gadget, \gEv\ computes the correct
      sibling roots of $\cir_A$. Thus, \evcond\ reconstructs the correct
      garblings $\gcir_{i \neq A}$, XORs these with $M$, and hence
      extracts $\gcir_A$.

      Now, it remains to show two points.
      First, we must show that the inputs are correctly fed to
      $\cir_A$. The second is to show that the garbage values from all
      branches $\cir_{i \neq A}$ are collected.
      %
      The first point is handled by the demultiplexer.
      %
      The demultiplexer implements via garbled rows simple logic: the
      correct input is forwarded to $\cir_A$, and garbage labels (that
      are independent of the input) is forwarded to all other circuits
      $\cir_{i \neq A}$.
      %
      The second point is handled by the multiplexer, generated by the
      emulation of all possible garbage branch evaluations.
      %
      We refer the reader to \Cref{sec:techOverview} for an extensive
      discussion of how this emulation is achieved.
      %
      In short, we carefully arrange \gadget\ such that there are
      only $\lceil \log |\vec \cir| \rceil$ garbage evaluations
      possible per branch.
      %
      Because the number of garbage evaluations is small, it is easy
      for \gGb\ to compute all of these cases itself.
      %
      With all possible garbage output labels available, garbage
      collection becomes the straightforward implementation of garbled
      rows. In particular, consider a single corresponding output wire
      from each branch.
      %
      The multiplexer first XORs together these labels.
      Now, it uses \act\ to construct garbled rows that hold all
      possible garbage values for this wire.
      Thus, depending on \act, \gEv\ will decrypt exactly the garbage
      values that were XORed into the overall sum.
      %
      XORing these with the overall sum leaves only the valid output.
  \end{itemize}
  \ourscheme\ is correct.
\end{proof}

\subsection{Security}

\begin{definition}[Strong Stackability]\label{def:stackable}
  A garbling scheme is \textbf{strong stackable} if:
  \begin{enumerate}
    \item
      For
      all circuits $\cir$
      and all inputs $\cirinp$,
      \[
        (\cir, \mat, \gEn(e, \cirinp)) \indist (\cir, \mat', \gcirinp')
      \]
      where
      $S$ is uniformly drawn,
      $(\mat, e, \cdot) = \gGb(1^\kappa, \cir, S)$,
      $\gcirinp' \drawnfrom{} \{0, 1\}^{|\gcirinp|}$,
      and $\mat' \drawnfrom{} \{0, 1\}^{|\mat|}$.
    \item
      The scheme is \textbf{projective}~\cite{CCS:BelHoaRog12}.
    \item
      There exists an efficient deterministic procedure $\lcolor$ that
      maps strings to $\{0, 1\}$ such that for all \cir\ and all
      projective label pairs $A^0, A^1 \in d$:
      \[
        \lcolor(A^0) \neq \lcolor(A^1)
      \]
      where $S$ is uniformly drawn and $(\cdot, \cdot, d) \gets \gGb(1^\kappa, \cir\ S)$.
    \item
      There exists an efficient deterministic procedure $\lkey$ that
      maps strings to $\{0, 1\}^\kappa$ such that for all \cir\ and all
      projective label pairs $A^0, A^1 \in d$:
      \[
        \lkey(A^0) \mid \lkey(A^1) \indist \{0, 1\}^{2\kappa}
      \]
      where $S$ is uniformly drawn and $(\cdot, \cdot, d) \gets \gGb(1^\kappa, \cir\ S)$.
  \end{enumerate}
\end{definition}

The above definition is given by \HK, with the exception of point 4.
Informally, stackability ensures that (1) circuit garblings `look
random' and (2) our scheme can manipulate labels generated by the
underlying scheme.
Since strong stackability simply adds point 4, the following lemma is
immediate:
\begin{lemma}
  Every strong stackable scheme is stackable.
\end{lemma}

The added requirement (point 4) allows us to relax
our security assumptions in comparison to \HK. In particular, for
each projective output pair $A^0, A^1$, we require that $A^0$ and
$A^1$ are unrelated.
This is achieved by requiring that the concatenation of these two
strings is indistinguishable from a random string of the same length.
This allows us to circumvent a problem: the \HK definition allowed labels in the underlying
scheme to be arbitrarily related to one another.
More precisely, while point 1 requires any particular labels seen by
\E\ look random, it does not require that \emph{all labels together}
look random.
%
This was problematic, because the output labels of the
underlying scheme were used to implement garbled tables, meaning that
the two labels were both used as private keys to a secret PRF.
%

%
Thus, \HK were forced to assume the existence of a random oracle in
order to ensure possible relationships in the output decoding string
did not compromise security.
%
However, by adding point 2, we ensure that the \emph{entire} decoding
string `looks random', and hence all labels must be independent.
This added requirement on the underlying scheme allows us to push our
proofs through in the standard model.

We note that all standard schemes can easily meet point 2:
if the scheme has randomly chosen labels, it trivially satisfies this
point.
%
Free XOR based schemes~(\cite{ICALP:KolSch08}) assume that all
pairs of labels are separated by a fixed constant $\Delta$, and so
they do not a priori meet point 2. However, it is easy to adjust such
schemes such that the final output gates return uncorrelated labels.
%
As a final note, while our scheme is secure in the standard model, we
of course adopt any additional security assumptions from the chosen
underlying scheme: e.g., isntantiating \ourscheme\ with the efficient
Half Gates scheme~\cite{EPRINT:ZahRosEva14} requires us to assume the
existence of a correlation robust hash function.

\begin{theorem}
  If \underscheme\ is stackable, then \ourscheme\ is stackable.
\end{theorem}
\begin{proof}
  By induction on the structure of the target circuit \cir.
  In the following, we use the phrase `$x$ looks random' to mean that $x$ is indistinguishable from a uniform string of the same length.
  \begin{itemize}
    \item Suppose \cir\ is a netlist.
      Then $\ourscheme.\gGb$ delegates to \underscheme,
      which is assumed to be stackable.
      %
      Netlists are stackable.
    \item Suppose \cir\ is a sequence $\sequential(\cir_0, \cir_1)$.
      By induction,
      both $\cir_0$ and $\cir_1$ are stackable.
      It remains to demonstrate that the intervening translation
      gadget preserves stackability.
      %
      Consider a subcomponent of the translator that translates one wire.
      %
      This subcomponent is implemented as an encrypted truth table with two ciphertexts of material (\Cref{sec:translate}).
      %
      Each row is the XOR of an input label with the
      output of $H$. $H$ is modeled as a random oracle and hence its output looks random.
      %
      Furthermore, correctly decrypting one row yields an
      input label for $\cir_1$ which, by induction, looks random.
      %
      Therefore, the ciphertexts constructed by $\gbtranslate$
      look random, so the translation component preserves stackability.
      %
      Sequences are stackable.
    \item Suppose \cir\ is a conditional $\conditional(\cir_0, \cir_1)$.
  \end{itemize}
  \ourscheme\ is stackable.
\end{proof}

\begin{definition}[Privacy]\label{def:privacy}
  A garbling scheme is \textbf{private} if
  there exists a simulator $\simulator_{prv}$ such that for
  any circuit $\cir$
  and all inputs $\cirinp$ of length $n$,
  the following are computationally indistinguishable:
   \[
  (\mat, \gcirinp, d)
  \indist
  \simulator_{prv}(1^\kappa, \cir, \cirout),
  \]
  where
  $S$ is uniform,
   $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$,
  $\gcirinp = \gEn(e,\cirinp)$,
  and $\cirout = \gev(\cir,\cirinp)$. 
\end{definition}

\begin{theorem}
  If \underscheme\ is stackable, then \ourscheme\ is private.
\end{theorem}
\begin{proof}
\end{proof}

\begin{definition}[Authenticity]\label{def:authenticity}
  A garbling scheme is \textbf{authentic} if for
  all circuits \cir,
  all inputs $\cirinp$ of length $n$,
  and all poly-time adversaries \adv 
  the following probability is negligible in $\kappa$:
  \[
    \pr{\gcirout' \neq \gEv(\cir, \mat,\gcirinp)
    \land
    \gDe(d, \gcirout') \neq \bot}
  \]
  where
  $S$ is uniform,
  $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$,
  $\gcirinp = \gEn(e,\cirinp)$,
  and $\gcirout' = \adv(\cir, \mat, \gcirinp)$
\end{definition}

\begin{theorem}\label{theorem:authenticity}
  If \underscheme is authentic, then \ourscheme is authentic.
\end{theorem}
\begin{proof}
\end{proof}
