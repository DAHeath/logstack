\section{\ourschemelong Correctness/Security}\label{sec:proof}

We discuss \ourschemelong's correctness and security properties.
We formalize our theorems in the~\cite{CCS:BelHoaRog12} framework (as
modified by \HK),
which requires a candidate garbling scheme to be \textbf{correct},
\textbf{oblivious}, \textbf{private}, and \textbf{authentic}.
% This section explains \ourschemelong's formal properties.

In addition, \HK\ introduced a new property, \textbf{stackability}, which
formalizes the class of garbling schemes whose garblings can be
securely stacked; hence stackable schemes are candidate underlying
schemes.
%
In this work, we strengthen the definition of stackability.  This
strengthening, which we call \textbf{strong stackability}, allows us to
prove security under standard assumptions (an improvement over \HK,
which required a random oracle assumption).
Strong stackability is strictly stronger than stackability: all
strongly
stackable schemes are stackable,
and all lemmas that hold for stackable schemes hold also for strongly
stackable schemes.
A key application of this second fact is that all stackable schemes
are trivially \textbf{oblivious}, so all strongly stackable schemes are
oblivious.
We prove security given a strongly stackable, correct, authentic,
private underlying scheme.

\HK\ showed that several standard garbling schemes are stackable, including
the state-of-the-art half-gates technique~\cite{EC:ZahRosEva15}.
We later argue that such schemes either are strongly stackable without
modification or can be easily adjusted.
Hence, our implementation can assume an RO and use half-gates as its underlying
scheme to achieve high performance.

\ourschemelong\ is itself strongly stackable, giving
flexibility in usage: while by design \ourschemelong\ handles vectors
of conditional branches, we also support arbitrarily nested
conditional control flow without modifying the source program.
%
We note that this nested usage \emph{does not} give $O(b\log b)$
computation, and so vectorized branches should favored where possible.

Due to a lack of space, we postpone most proofs to Supplementary
Material.
% Because \ourschemelong\ is strongly stackable, it is trivially
% \textbf{oblivious}~\HK,
% and so we do not discuss obliviousness further.



\subsection{Correctness}\label{sec:correctness}

\begin{definition}[Correctness]\label{def:correct}
  A garbling scheme is \textbf{correct} if for
  all circuits $\cir$,
  all input strings $\cirinp$ of length $\inpsize(\cir)$,
  and all pseudorandom seeds $S$:
  \[
    \gDe(d, \gEv(\cir, \mat,\gEn(e,\cirinp))) = \gev(\cir,\cirinp)
  \]
  where $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$
\end{definition}

A correct scheme implements the semantics specified by \gev.
Proof of the following is formalized in Supplementary Material.

\begin{theorem}\label{theorem:correctness}
  If \underscheme\ is correct, then \ourschemelong\ is correct.
\end{theorem}

\subsection{Security}

The following definition is derived from the corresponding definition
of~\HK; we discuss its motivation (support for PRF-based garbling
gadgets) and technical differences with \HK immediately after we
present it formally below.

\begin{definition}[Strong Stackability]\label{def:stackable}
  A scheme is \textbf{strongly stackable} if:
  \begin{enumerate}
    \item
      For
      all circuits $\cir$
      and all inputs $\cirinp$,
      \[
        (\cir, \mat, \gEn(e, \cirinp)) \indist (\cir, \mat', \gcirinp')
      \]
      where
      $S$ is uniformly drawn,
      $(\mat, e, \cdot) = \gGb(1^\kappa, \cir, S)$,
      $\gcirinp' \drawnfrom{} \{0, 1\}^{|\gcirinp|}$,
      and $\mat' \drawnfrom{} \{0, 1\}^{|\mat|}$.
    \item
      The scheme is \textbf{projective}~\cite{CCS:BelHoaRog12}.
    \item
      There exists an efficient deterministic procedure $\lcolor$ that
      maps strings to $\{0, 1\}$ such that for all \cir\ and all
      projective label pairs $A^0, A^1 \in d$:
      \[
        \lcolor(A^0) \neq \lcolor(A^1)
      \]
      where $S$ is uniformly drawn and $(\cdot, \cdot, d) \gets \gGb(1^\kappa, \cir\ S)$.
    \item
      There exists an efficient deterministic procedure $\lkey$ that
      maps strings to $\{0, 1\}^\kappa$ such that for all \cir\ and all
      projective label pairs $A^0, A^1 \in d$:
      \[
        \lkey(A^0) \mid \lkey(A^1) \indist \{0, 1\}^{2\kappa}
      \]
      where $S$ is uniformly drawn and $(\cdot, \cdot, d) \gets \gGb(1^\kappa, \cir\ S)$.
  \end{enumerate}
\end{definition}

The above definition is given by \HK, with the exception of point 4.
Informally, stackability ensures (a) that circuit garblings `look
random' and (b) that our scheme can manipulate labels generated by the
underlying scheme.
Since strong stackability simply adds point 4, the following lemma is
immediate:
\begin{lemma}\label{lemma:stack-strongstack}
  Every strongly stackable scheme is stackable.
\end{lemma}

We briefly explain the role of \lcolor\ and \lkey. As with \HK, we
use the output labels of the underlying scheme as keys in subsequent
garbled gadgets.  The \lkey\ procedure allows us to extract a
\emph{suitable PRF key} from each label. At the same time, we make use
of the classic point-and-permute trick to reduce the number of PRF calls
needed to evaluate garbled gadgets: we use the \lcolor\ as the bit
that instructs which garbled row to decrypt.  Note that because we
essentially `split’ each output label into a key and a color, we
`lose’ bits of the underlying scheme’s labels when we invoke
\lkey. We stress that this is not an issue: the required key
length for the next PRF application can be restored as we require
\lkey\ output to be $\kappa$ bits long. All point-and-permute schemes
have a similar approach.

The added requirement (point 4) allows us to relax
our security assumptions in comparison to \HK. For
each projective output pair $A^0, A^1$, we require that $\lkey(A^0)$ and
$\lkey(A^1)$ are unrelated.
This is achieved by requiring that the concatenation of these two
strings is indistinguishable from a random string of the same length.
This allows us to circumvent a problem: the \HK definition allowed labels in the underlying
scheme to be arbitrarily related.
More precisely, while point 1 requires that any particular set of labels seen by
\E\ look random, it does not require that \emph{all labels together}
look random.
%
This was problematic, because the output labels of the
underlying scheme were used to implement garbled tables, so
the two possibly related labels were both used as PRF keys.
%
Using related keys is outside the scope of the standard
PRF security definition.
%
Thus, \HK were forced to assume the existence of a random oracle
to ensure possible relationships in the output decoding string
did not compromise security.
%
By adding point 4, we ensure that the \emph{entire} decoding
string `looks random', so all labels must be independent.
This added requirement on the underlying scheme allows us to push our
proofs through in the standard model.


Many standard schemes are compatible with strong stackability:
if the scheme is stackable and has randomly chosen output labels, it
trivially satisfies our definition.
%
Free XOR based schemes~\cite{ICALP:KolSch08} use
pairs of labels separated by a fixed constant $\Delta$, and so
are not \emph{a priori} strongly stackable. However, it is easy to adjust such
schemes such that the final output gates return independent labels.
%
As a final note, while our scheme is secure in the standard model, we
of course adopt any additional security assumptions from the chosen
underlying scheme: e.g., instantiating \ourschemelong\ with the efficient
Half Gates scheme~\cite{EC:ZahRosEva15} requires us to assume the
existence of a circular correlation robust hash function.

We prove the following in Supplementary Material. The proof
utilizes properties of \underscheme\ and of a PRF to show
that \ourschemelong's garblings `looks random'.

\begin{theorem}\label{thm:strongstack}
  If \underscheme\ is strongly stackable, then \ourschemelong\ is strongly stackable.
\end{theorem}
\begin{definition}[Obliviousness]\label{def:obliviousness}
  A garbling scheme is \textbf{oblivious} if there exists a
  simulator $\simulator_{obv}$ such that for
  any circuit $\cir$
  and all inputs $\cirinp$ of length $\inpsize(\cir)$,
  the following are indistinguishable:
  \[
    (\cir, \mat, \gcirinp) \indist \simulator_{obv}(1^\kappa, \cir)
  \]
  where
   $S$ is uniform,
   $(\mat, e, \cdot) = \gGb(1^\kappa,\cir,S)$
  and $\gcirinp = \gEn(e,\cirinp)$.
\end{definition}

Obliviousness ensures that the garbled circuit with input labels can be simulated, and
hence reveals no extra information to \E.
\HK\ proved that every stackable scheme is trivially oblivious:
drawing a random string of the correct length is a suitable simulator.
This fact, combined with \Cref{lemma:stack-strongstack} and
\Cref{thm:strongstack} implies two
immediate facts:
\begin{lemma}\label{lemma:obliviousness}
  Every strongly stackable scheme is oblivious.
\end{lemma}
\begin{theorem}\label{thm:oblivious}
  If \underscheme\ is strongly stackable, then \ourschemelong\ is oblivious.
\end{theorem}

\begin{definition}[Authenticity]\label{def:authenticity}
  A garbling scheme is \textbf{authentic} if for
  all circuits \cir,
  all inputs $\cirinp$ of length $\inpsize(\cir)$,
  and all poly-time adversaries \adv\
  the following probability is negligible in $\kappa$:
  \[
    \pr{\gcirout' \neq \gEv(\cir, \mat,\gcirinp)
    \land
    \gDe(d, \gcirout') \neq \bot}
  \]
  where
  $S$ is uniform,
  $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$,
  $\gcirinp = \gEn(e,\cirinp)$,
  and $\gcirout' = \adv(\cir, \mat, \gcirinp)$
\end{definition}

Authenticity ensures that an adversary cannot compute GC output labels
except by running the scheme as intended.

We prove the following in Supplementary Material. The proof
utilizes properties of \underscheme\ and of a PRF to show
that an adversary cannot compute GC output labels except by running
\ourschemelong.

\begin{theorem}\label{thm:authenticity}
  If \underscheme\ is authentic, then \ourschemelong\ is authentic.
\end{theorem}

\begin{definition}[Privacy]\label{def:privacy}
  A garbling scheme is \textbf{private} if
  there exists a simulator $\simulator_{prv}$ such that for
  any circuit $\cir$
  and all inputs $\cirinp$ of length $\inpsize(\cir)$,
  the following are computationally indistinguishable:
   \[
  (\mat, \gcirinp, d)
  \indist
  \simulator_{prv}(1^\kappa, \cir, \cirout),
  \]
  where
  $S$ is uniform,
   $(\mat, e, d) = \gGb(1^\kappa,\cir,S)$,
  $\gcirinp = \gEn(e,\cirinp)$,
  and $\cirout = \gev(\cir,\cirinp)$.
\end{definition}


Privacy ensures that \E, who is given access to
$(\mat, \gcirinp, d)$, learns nothing except what can be learned from the output
$\cirout$. I.e., \G's input is protected.

We prove the following in Supplementary Material. The proof
utilizes properties of \underscheme\ and of a PRF to show
that \E's view can be simulated.
% that an adversary cannot compute GC output labels except by running
% \ourschemelong.

\begin{theorem}\label{thm:privacy}
  If \underscheme\ is private, authentic, and strongly stackable, then
  \ourschemelong\ is private.
\end{theorem}
