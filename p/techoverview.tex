
\section{Technical Overview of Our Approach}
\label{sec:techOverview}

We  now review in our main contributions with sufficient  detail to present most interesting  technical challenges and  solutions.

\subsection{$O(b\log b)$ Stacked Garbling}
\label{sec:techOverviewSG}

Our main contribution is reducing the computation associated with branch processing in SGC from $O(b^2)$ to $O(b \log b)$.

We now continue the discussion of~\Cref{sec:intuition} and add  technical detail.  
Our main task is the garbage collection of output labels of {\em incorrectly guessed} (\truth,\guess) combinations 
%w.r.t. taken (active) branch, 
where
\guess is \E's guess of the active branch, and \truth defines the active branch w.r.t. \guess.   Wlog, let $b$ be a power of $2$ to simplify notation.

Fix one of $b$ choices for \guess.  In contrast with previous work~\HK, which then considers $b$ choices for \truth independently from \guess, we define \truth\ {\em in relation} to \guess, and consider fewer \truth options.  Namely,
% for each tree level $i$, 
we  let \truth  denote in which sibling subtree of \guess the executed branch resides (cf. discussion in~\Cref{sec:intuition}).  There are $\log b$ choices for this \truth.

Consider an illustrative example of~\Cref{fig:seed-tree}, where $\guess=0$.  Then any of active branches $C_4-C_7$ will correspond to $\truth = 1$ as they all belong to the level-$1$ sibling subtree of $C_0$.  We want \E's unstacking and evaluation to result in identical garbage output labels across all cases when active branch is one of $C_4-C_7$  (and similarly across each level-$i$ subtree).  To achieve this, \E will use garbled labels corresponding to the ID of the active branch \aid.

% We achieve this by 

% (the choice of $\truth = 0$ is only valid for the correct guess), one of which corresponds to the correct guess.  If  the guess is correct, active branch resides in none of the $\log b$ sibling subtrees, and we can denote $\truth=0$ in this case. 

%We now show how \G and \E can efficiently process each of the $b\log b$ cases.   

Recall, as part of GC  evaluation, \aid is computed by the circuit, and \E obtains the corresponding $ \log b$-long vector of GC labels $\vec S$, where
%, whose corresponding plaintext values define the id of the active branch. 
 %each label 
$S[i] \in \{S^0[i],S^1[i]\}$; \G of course knows all labels $S^0[i],S^1[i]$.
% he uses the labels as seeds in garbling the branches as follows.
\G  garbles branches  $C_0,...,C_7$ as follows.  \G generates  random seeds for 
%each internal node and 
each leaf in the tree.  He uses leaf seed $s_i$ to garble the branch $\cir_i$ and stacks all garbled branches $\mat=\bigoplus_i \gcir_i$.  \G additionally generates and sends to \E a garbled gadget that will aid \E in garbled  branch reconstructions.  We will explain how this gadget is constructed and used by defining how \E will process her guesses:
%If \E guesses correct, and hence obtains  all seeds unequal to target branch, she will recover the evaluated garbled branch.




Let's return to our example of~\Cref{fig:seed-tree} with $b=8$ branches and $\guess=0$. Let's consider $\truth = 1$ (i.e. $\aid \in \{4,...,7\}$ and $S[0] = S^1[0]$).
% and refer to the illustration of depicting the $b=8$ branches and the binary tree built on them.  It will be clear that this idea naturally generalizes to any \guess and $b$.  

\E starts processing at the root of the tree.  Recall the basic SGC idea of~\HK: \E obtains seeds for reconstructing branches {\em not} taken and unstacks them based on its guess of the truth.  Since \E's $\guess=0$, she will need to unstack the {\em entire} level-1 sibling subtree tree $\truth = 1$ using obtained labels  $\vec S$.
How convenient: \G could derive the seeds for the entire level-1 right subtree from a single  seed denoted $s_{4-7}$ on~\Cref{fig:seed-tree} (and symmetrically seeds for left subtree -- from seed $s_{0-3}$).  Now, following the \HK basic idea, since taken branch is in the right subtree, 
 \E will obtain the complementary label $S[0]=s_{0-3}$.  
 
 She will use $S[0]$ to derive (incorrectly) seeds $s'_4-s'_7$ and will unstack all $C_4-C_7$ in a {\em single specific} wrong way, no matter what $\aid\in\{4,...,7\}$ is.  Second crucial idea now is to ensure that there is {\em no further variation} in \E obtaining garbage due to \E's attempted unstacking of other circuits $C_1-C_3$.  This is achieved with our garbled gadget, applied by \E at tree each traversal level $i$, that recognizes whether a \guess and \aid branches are in different sibling subtrees, and, if so, leads \E to deriving the {\em same} seeds for garbling the remaining unstacked circuits, no matter how the remaining bits of \truth and \guess relate.  This gadget is easy to construct, since for each element of $\vec S$, there are only two possible options.  We must of course be careful  that the seeds derived with the help of this gadget look like random strings, and ``true'' seeds used by \G are indistinguishable from the possible garbage seeds.

To summarize, we showed that for our considered $\guess=0$ and {\em any}  $\aid \in \{4-7\}$, \E will unstack to obtain a single specific (incorrectly) recovered GC which she evaluates.

Let's now consider the same $\guess=0$ and a different $\truth = 2$.  \E will obtain the label $S[0]=s_{4-7}$.  She will use it to (correctly) derive seeds $s_4-s_7$ and will unstack $C_4-C_7$.  She will then attempt to unstack the branches of the next sibling subtree $C_2-C_3$.  She received  $S[1] = s_{0-1}$, uses it (in conjunction with our gadget) to (incorrectly) derive $s_2,s_3$ and unstacks $C_2-C_3$ in a single specific wrong way. By the same argument as above, our gadget ensures that subsequent unstacking is identical  no matter how the remaining bits of \truth and \guess relate.

Observe that for our considered $\guess=0$ and {\em any} true branch id $\in \{2-3\}$, \E will unstack to obtain a single specific (incorrectly) recovered GC which she evaluates.

Continuing this argument, we conclude that all in all, for our considered $\guess=0$ and {\em any} true branch id unequal to \guess, \E will unstack to obtain one of exactly $\log b$ garbage circuits.


Finally, we note  that this argument clearly generalized to every guess \guess.

\vlad{need to add argument counting total num evaluations}


\vlad{end of argument}

\bigskip
 relying on the fact that

  \G including a garbled ga











We want to allow \E to deterministically obtain any seed from any of its parents (i.e. nodes on the path to the root).  For example, \E should be able to deterministically obtain any of the seeds $s_4,...,s_7$ from seed $s_{4-7}$, and seeds $s_4, s_5$ -- from seed $s_{4-5}$. 


 Because derivation is deterministic, deriving from another seed in place of $s_{4-7}$, results in 
Clearly, this is easy to achieve, e.g., using a suitable garbled table gadget.








 As in \HK, our \E will make a guess $\guess\in[0..b-1]$ and use these labels as seeds to reconstruct branches guessed as {\em not} taken.  If the guess was correct, then correct garbled branches will be unstacked, and \E will have obtained the correct garbling of the active branch.  Crucially, if the guess was incorrect, we obtain predictable garbage output labels.



By way of example, let's consider the special case of $\guess=0$ and $\truth = 100$ and refer to the illustration of~\Cref{fig:seed-tree} depicting the $b=8$ branches and the binary tree built on it.  It will be clear that this idea naturally generalizes to any \guess.  \E starts processing at the root of the tree.  She made $\guess = 0$, while active branch is $C_4$.  



 Key idea of our work and difference from~\HK is that:
\begin{itemize}
	\item for any tree level $i$, if active branch is 
	\item 
\end{itemize}




 Consider at each level of the tree the dichotomy of whether leaves indexed by \guess and \truth are in the same subtree. Our idea is, given a fixed \guess, to  enforce that \E identically processes \guess for {\em all} values of \truth which belong to the same sibling subtree of guess. This narrows \Gâ€™s uncertainty for each value of \guess: each value of \guess has only $\log b$ possible \truth options, one for each sibling subtree of \guess.  In turn, this results in $b\log b$  sets of garbage labels, and $b\log b$ garblings required by \G. \todo{and by \E?}

%In this work, we address the technical challenge of designing garbling gadgets and  the stacking  to support security and correctness 

\medskip



the following is to move to technical intuition maybe.
\begin{itemize}
	
	\item The conditional branches are \emph{nested}.
	That is, instead of organizing $b$ branches as a vector, we
	organize them into a binary tree.
	Suppose \E guesses that a particular branch $\cir_i$ is taken,
	while in fact $\cir_j$, a member of a different subtree, is taken.
	The key idea of our approach is that we ensure that when \ev
	garbles the entire subtree containg $\cir_j$ but not $\cir_i$, she
	computes the same material, regardless of $j$.\todo{intuition still unclear}
	\item The multiplexer is \emph{not stacked}.
	The careful reader familiar with \cite{EPRINT:HeaKol20b} may be
	confused about our key idea: Stacked Garbling first presents a
	recursive binary tree approach to branching that they later
	discard in favor of a more efficient vector approach.
	So why is our binary tree approach better?
	The problem with \cite{EPRINT:HeaKol20b}'s recursive construction
	is that the evaluator recursively computes the multiplexer for
	nested sub-conditionals.
	However, doing so leads to a recursive emulation whereby \E
	emulates herself (and hence \G emulates himself as well).
	This recursion leads to quadratic cost for both players.
	The way out is to treat the multiplexer separately, and to opt not
	to stack it.
	If multiplexers are not stacked, then \E need not compute them.
\end{itemize}


% At a high level, the circuit generator, i.e. the player who constructs
% the material,





\subsection{Lower bound)}
\label{sec:techOverviewLB}






\subsection{Stacked garbling without Random Oracles)}
\label{sec:techOverviewRO}




