
\section{Technical Overview of Our Approach}
\label{sec:techOverview}

We  now review in our main contributions with sufficient  detail to present most interesting  technical challenges and  solutions.

\subsection{$O(b\log b)$ Stacked Garbling}
\label{sec:techOverviewSG}

Our main contribution is the reduction of SGC computation
from $O(b^2)$ to $O(b \log b)$.  Our constants are also
low: together \G and \E make a total of $2 b \log b + b$ calls to \Gb\
and $b(\log b + 1)$ calls  to \Ev.

We now continue the discussion from~\Cref{sec:intuition} in more detail.
Our main task is the garbage collection of output labels of {\em
incorrectly guessed} $(\truth, \guess)$ combinations 
%w.r.t. taken (active) branch, 
where
\guess is \E's guess of the active branch, and \truth defines the active branch w.r.t. \guess.
Wlog, let $b$ be a power of $2$ to simplify notation.
Consider a binary tree where the leaves are the $b$ branches $\cir_1,...,\cir_b$.  The tree will provide a convenient infrastructure to group branches and cases to unify processing.


Fix one of $b$ choices for \guess.  In contrast with previous work~\HK, which then considers $b$ choices for \truth independently from \guess, we define \truth\ {\em in relation} to \guess, and consider fewer \truth options.  Namely,
% for each tree level $i$, 
we  let \truth  denote in which sibling subtree of \guess the executed branch resides (cf. notation and discussion in~\Cref{sec:intuition}). 
Given a fixed \guess, there are only exactly  $\log b$ choices for \truth\footnote{Recall, we focus on the task of garbage collection due and consider only  incorrect guesses;  managing correctly recovered labels of correctly guessed branches is straightforward and cheap.}.

Consider the illustrative example in~\Cref{fig:seed-tree}, where $\guess=0$.
Consider the four scenarios where one of the branches $\cir_4-\cir_7$ is active.
These four scenarios each correspond
to $\truth = 1$: $\cir_4-\cir_7$ all belong to the level-$1$ sibling subtree of
$\cir_0$.
%
Our objective is to ensure that \E's unstacking and evaluation in each
of these four cases is \emph{identical}.  Similarly we want to achieve identical processing for all leaves of each level-$i$ sibling subtree.
Let \aid denote the ID of the active branch. That is, \aid is a $\log
b$-bit integer that points to the active branch.
% To achieve our objective, \E will use garbled labels corresponding to
% \aid to compute seeds for the various nodes in the tree.

% Recall, as part of GC  evaluation, \aid is computed by the circuit, and \E obtains the corresponding $ \log b$-long vector of GC labels $\vec S$, where
% $S[i] \in \{S^0[i],S^1[i]\}$; \G of course knows all labels $S^0[i],S^1[i]$.

\subsubsection{Actions and gadgets of \G.}

In the context of the exampe of~\Cref{fig:seed-tree}, \G  garbles branches  $\cir_0,...,\cir_7$ as follows.  \G chooses a random
seed for the root of the tree (denoted $s_{0-7}$ for the $8$-leaf tree
in~\Cref{fig:seed-tree}), and uses it to pseudorandomly derive seeds
for each node of the tree.  This is done in the standard manner, e.g.,
the immediate children of a seed $s$ are the PRF evaluations on inputs
$0$ and $1$ with the key $s$.
\G uses each leaf seed $s_i$ to garble the corresponding branch $\cir_i$ and stacks all garbled branches $\mat=\bigoplus_i \gcir_i$.  
%
This material $\mat$ is the large string that \G\ ultimately sends
across the network to \E.
We note two facts about $\mat$ and about the active branch $\aid$.
\begin{enumerate}
  \item \textbf{Correctness}: if \E\ obtains the $\log b$ seeds of the
    \emph{sibling roots} (i.e. roots of sibling subtrees) of
    $\aid$, then she can regarble all circuits $\gcir_{i\neq \act}$,
    unstack by XORing with \mat, and obtain $\gcir_\act$, allowing her to
    correctly evaluate $\cir_\act$.
  \item \textbf{Security}: \E\ must not obtain any correct seed
    corresponding to any ancestor of \aid. If she did, she would learn (by garbling) the
    encoding of wire labels which would allow her to decrypt all
    intermediate wire values in $\cir_\act$.
    %
    Instead, \E\ will obtain `garbage' seeds indistinguishable yet
    distinct from the correct seeds generated by \G.
\end{enumerate}

To facilitate secure garbled evaluation of the conditional and meet the requirements of these two facts, in addition to \mat,
\G  generates and sends to \E a small (linear in the
number of branches with small constants) garbled gadget
\gadget.  \gadget will aid \E in securely reconstructing branch material. 
Specifically, \gadget takes as input labels corresponding to \aid and
produces candidate seeds for {\em each} node in the tree.
For each node \node, \gadget constructs a correct (i.e. as generated by \G) seed $s_\node$
if and only if \node is a sibling root  of the leaf \aid.
\gadget can easily be implemented as a collection of garbled rows.
Importantly, since this is a fixed
gadget, when evaluated on a node \node that is not a sibling root of
\aid, \E will obtain a {\em single} predictable to \G\ fixed garbage
seed. 
% We need to ensure this garbage value is the same for every
% \aid. This is easy to do.  Details follow:

In more detail, \gadget can be described in two steps:\vlad{put gadget in frame?}
\begin{enumerate}
  \item
    \gadget computes for each node \node in the tree the following function \issr(\node,\aid):
    `Is \node a sibling root of $\aid$?' This Boolean function can be
    efficiently realized using a GC with cost proportional to the size
    of the tree (i.e. $2b$ AND gates). Let $\issr_\node$ be
    the output of this function for node \node.
  \item
    \gadget outputs a seed \es(\E's seed) based on \issr():
    %maps the above intermediate encrypted truth values to seeds for each \node as follows:
    \[
    \es_\node =
    \begin{cases}
        s_\node,& \text{if } \issr_\node\\
        s_\node',& \text{otherwise}
    \end{cases}
  \]
    Where $s_\node'$ is a uniform string indistinguishable from
    $s_\node$. If \node is a sibling root of $\aid$, then
    \E\ obtains the correct seed $s_\node$, and otherwise obtains a garbage
    seed $s_\node'$. $s_\node'$ is fixed for each node \node, and is independent of \aid.
    We implement \gadget using only a single garbled row
    per node.
\end{enumerate}

For example in~\Cref{fig:seed-tree}, if active branch is $\aid=4$, then applying the gadget to nodes $\node_{0-3}, \node_{6-7}, \node_{5}$ will allow the reconstruction of correct seeds $s_{0-3}, s_{6-7}, s_{5}$.  Applying \gadget to other nodes\vlad{ I removed ``(which would under the hood mean decrypting a correspondingly different garbled row)'' as it somewhat conflicts with descr of \gadget} will result in \E obtaining fixed garbage seeds.  If  active branch were $\aid=3$, then applying \gadget to nodes $\node_{4-7}, \node_{0-1}, \node_{2}$ will allow the reconstruction of correct seeds $s_{4-7}, s_{0-1}, s_{2}$. Garbage seeds reconstructed in, e.g., node $\node_{4-5}$ will be the {\em same} in both cases.


\subsubsection{Actions of \E.}

It is now intuitive how \E will proceed with unstacking.  She will apply the gadget \gadget and obtain a tree of random-looking seeds; of $2b$ seeds, only $\log b$ seeds just off the path to \aid (corresponding to sibling roots) will be correct.
\E will guess \guess; assuming \guess, she will use (only) the sibling seeds of \guess to derive all  $b-1$ leaf seeds not equal to \guess.  She then garbles the $b-1$ branches $\cir_i$ and unstacks the corresponding GCs $\gcir_i$.

Clearly, if $\guess=\aid$, she will derive the intended leaf seeds $s_{i\neq\aid}$, unstack the intended garbled circuits $\gcir_{i\neq\aid}$, and therefore will obtain the correct GC $\gcir_\aid$.   Let's consider the case that her guess is wrong. %Firstly, there is no security violation since she will never receive any additional valid seeds;
In this case, \E will simply unstack wrong branches garbled with the wrong seeds.  As we noted above, since \E will never receive any additional valid seeds, there is no securlity loss.  We next see that the number of different garbage labels we must collect is small, and further they can be collected efficiently.





\vlad{Removed this too "Finally, we note  that this argument clearly generalizes to the tree of every size."}


\subsubsection{Computational cost accounting.} Let's now verify that we indeed reduced the number of calls to \Gb\ and \Ev\ to $O(b \log b)$.  This is easily done by first considering how many such calls are made by \E.  
Consider branch $\cir_i$.  It is garbled $\log b$ times, once with a seed (ultimately) derived from each seed on the path to the root.  Thus, total number of calls by \E to \Gb\ is $b \log b$ and to \Ev\ is exactly $b$.  




To construct \gadget, \G must obtain all possible garbage labels. 
We now demonstrate that the total cost to the generator is $b (\log b + 1)$ calls to \Gb\ and $b \log b$ calls to \Ev.
First let’s consider only \Gb\ and consider the number of ways \E\ can garble a specific circuit $\cir_i$. Clearly, this is exactly $\log b+1$.

Now let’s consider the number of calls needed to \Ev.
Recall that our goal was to ensure that \E constructs the same garbage output labels for a branch $\cir_i$ in each scenario where \aid is in some fixed sibling subtree of $\cir_i$. Note that the logic of our gadget ensures that \E will obtain the same sibling root seeds in each of these scenarios, and therefore she will construct the same garblings. Hence, since there are $\log b$ sibling subtrees of $\cir_i$, $\cir_i$ has only $\log b$ possible garbage output labels.



\ignore{

 Hence \G emulates the work done by \E in its entirety  for {\em every} possible value of $\truth\in\{1,...,\log b\}$.  Hence it makes total  $b \log^2 b$ number of calls to \Gb\ and $b \log b$ calls to  \Ev.  
%hence it  makes  $\log b$ calls per branch to \Gb\ and $b\log b$ total calls to \Ev\ to obtain all garbage labels.
}



















\ignore{



We want to allow \E to deterministically obtain any seed from any of its parents (i.e. nodes on the path to the root).  For example, \E should be able to deterministically obtain any of the seeds $s_4,...,s_7$ from seed $s_{4-7}$, and seeds $s_4, s_5$ -- from seed $s_{4-5}$. 


 Because derivation is deterministic, deriving from another seed in place of $s_{4-7}$, results in 
Clearly, this is easy to achieve, e.g., using a suitable garbled table gadget.








 As in \HK, our \E will make a guess $\guess\in[0..b-1]$ and use these labels as seeds to reconstruct branches guessed as {\em not} taken.  If the guess was correct, then correct garbled branches will be unstacked, and \E will have obtained the correct garbling of the active branch.  Crucially, if the guess was incorrect, we obtain predictable garbage output labels.



By way of example, let's consider the special case of $\guess=0$ and $\truth = 100$ and refer to the illustration of~\Cref{fig:seed-tree} depicting the $b=8$ branches and the binary tree built on it.  It will be clear that this idea naturally generalizes to any \guess.  \E starts processing at the root of the tree.  She made $\guess = 0$, while active branch is $C_4$.  





 Consider at each level of the tree the dichotomy of whether leaves indexed by \guess and \truth are in the same subtree. Our idea is, given a fixed \guess, to  enforce that \E identically processes \guess for {\em all} values of \truth which belong to the same sibling subtree of guess. This narrows \G’s uncertainty for each value of \guess: each value of \guess has only $\log b$ possible \truth options, one for each sibling subtree of \guess.  In turn, this results in $b\log b$  sets of garbage labels, and $b\log b$ garblings required by \G. \todo{and by \E?}


}


	
	


% At a high level, the circuit generator, i.e. the player who constructs
% the material,





\subsection{Lower bound}
\label{sec:techOverviewLB}






\subsection{Stacked garbling without Random Oracles}
\label{sec:techOverviewRO}




