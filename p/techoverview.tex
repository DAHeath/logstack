
\section{Technical Overview of Our Approach}
\label{sec:techOverview}

We  now review in  our main contributions at high level, but with some technical detail.
\subsection{$O(b\log b)$ Stacked Garbling}
\label{sec:techOverviewSG}

Our main contribution is reducing the computation associated with branch processing in SGC from $O(b^2)$ to $O(b \log b)$.

We now continue the discussion of~\Cref{sec:intuition}.  
Recall, we consider (\truth,\guess) combinations w.r.t. taken (active) branch.  Fix one of $b$ choices for \guess.  In contrast with previous work~\HK, which considers $b$ choices for \truth, we let \truth  denote in which sibling subtree of \guess the executed branch resides.  There are $\log b$ choices for this \truth.  If \G and \E can efficiently process each of these $b\log b$  (\truth,\guess) combinations  (we show that they can!), we achieve the improved $O(b\log b)$ computation cost.

We reduce the number of possible \truth choices  {\em with respect to  \guess}.  For this, we  change the semantics of variable \truth: it now will not mean which of $b$ branches is active; instead 



 Consider at each level of the tree the dichotomy of whether leaves indexed by \guess and \truth are in the same subtree. Our idea is, given a fixed \guess, to  enforce that \E identically processes \guess for {\em all} values of \truth which belong to the same sibling subtree of guess. This narrows \Gâ€™s uncertainty for each value of \guess: each value of \guess has only $\log b$ possible \truth options, one for each sibling subtree of \guess.  In turn, this results in $b\log b$  sets of garbage labels, and $b\log b$ garblings required by \G. \todo{and by \E?}

%In this work, we address the technical challenge of designing garbling gadgets and  the stacking  to support security and correctness 

\medskip



the following is to move to technical intuition maybe.
\begin{itemize}
	
	\item The conditional branches are \emph{nested}.
	That is, instead of organizing $b$ branches as a vector, we
	organize them into a binary tree.
	Suppose \E guesses that a particular branch $\cir_i$ is taken,
	while in fact $\cir_j$, a member of a different subtree, is taken.
	The key idea of our approach is that we ensure that when \ev
	garbles the entire subtree containg $\cir_j$ but not $\cir_i$, she
	computes the same material, regardless of $j$.\todo{intuition still unclear}
	\item The multiplexer is \emph{not stacked}.
	The careful reader familiar with \cite{EPRINT:HeaKol20b} may be
	confused about our key idea: Stacked Garbling first presents a
	recursive binary tree approach to branching that they later
	discard in favor of a more efficient vector approach.
	So why is our binary tree approach better?
	The problem with \cite{EPRINT:HeaKol20b}'s recursive construction
	is that the evaluator recursively computes the multiplexer for
	nested sub-conditionals.
	However, doing so leads to a recursive emulation whereby \E
	emulates herself (and hence \G emulates himself as well).
	This recursion leads to quadratic cost for both players.
	The way out is to treat the multiplexer separately, and to opt not
	to stack it.
	If multiplexers are not stacked, then \E need not compute them.
\end{itemize}


% At a high level, the circuit generator, i.e. the player who constructs
% the material,





\subsection{Lower bound)}
\label{sec:techOverviewLB}






\subsection{Stacked garbling without Random Oracles)}
\label{sec:techOverviewRO}




