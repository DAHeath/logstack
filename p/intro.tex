\section{Introduction}\label{sec:intro}

Secure two party computation (2PC) of programs representable as Boolean circuits can be efficiently achieved using garbled circuits (GC).
%
However,  circuit-based MPC in general is problematic because conditional
control flow does not have an efficient circuit representation:
in the cleartext program, only the taken execution is computed whereas in
the circuit \emph{all} branches must be computed.
%While this creates obvious relative overheads in conditional statements, the most significant impact is on general control flow, such as a sequence of loops.

%
Until recently, it was assumed that the players must not only compute
all branches, but also transmit a string of \emph{material} (i.e., the garbled circuit itself) 
proportional to all branches.  
Since communication is the bottleneck in GC, transmitting this large string was
problematic for programs with conditional behavior.

Stacked Garbling~\HK, which we %(and \HK) 
interchangeably call Stacked Garbled Circuit (SGC), shows that
this expensive branching-based communication blow-up is unnecessary: the players need only
send enough material for the single longest branch. This single
piece of \emph{stacked} material can be re-used across all conditional branches, thus
dramatically reducing communication cost.
%
This improvement does come with one important downside:
Stacked Garbling requires the players to compute far more than they
would have without stacking.
In particular, for a conditional with branching factor $b$, the \HK GC
generator must evaluate each branch under encryption $b-1$ times, and
he hence pays $O(b^2)$ total computation.
In contrast, standard garbling uses computation linear in the number
of branches.

In this work, we present a new construction for SGC that incurs
only $O(b \log b)$ computation for both players while
retaining the important communication improvement of \HK.
%
The construction also features low constants, and hence opens the door
to using SGC even in the presence of very high branching factors
without computation becoming prohibitive.


\subsection{A case for a high branching factor}
\label{sec:motivationHighB}

Clearly, conditional branching is ubiquitous in programming, and our work significantly
improves the secure evaluation of programs with
branching.
Moreover, the efficient support for programs with \emph{high branching factor}
is more important than it may first appear.

Our main observation is that free/cheap branching, such as what is
achieved by our work, enables optimized handling of \emph{arbitrary
control flow}, including arbitrary repeated and/or nested loops.
%
Specifically, we can repeatedly \emph{refactor} the source program
until the program is a single loop whose body conditionally dispatches
over straightline fragments of the original program\footnote{%
  As a brief argument that this is clearly possible, consider that a
  CPU has this exact structure: in this case the `straightline
  fragments' are the individual instruction types handled by the CPU.
}.
However, these types of refactorings often lead to conditionals with
high branching factor.

As a simple example,
consider a program $P$ consisting of a loop $L_1$ followed by a loop
$L_2$.  Assume the total upper bound on runtime (total number of loop
iterations $T$) of $P$ is known, as is usual in MPC.
For security, we must protect the number of iterations $T_1$ of $L_1$
and $T_2$ of $L_2$.
Implementing such a program with standard Yao GC requires us to
pay double of the cost achievable with stacked garbling: we must
execute loop $L_1$ $T$ times followed by executing $L_2$ $T$ times.
At the same time, SGC can simply execute  $\stack(L_1, L_2)$ $T$
times, a circuit with a significantly smaller garbling. This observation corresponds to the
following refactoring:
\[{\tt while (e_0) \{ s_0 \} ; \ while (e_1) \{ s_1 \}}
\longrightarrow {\tt while (e_0 \lor e_1) \{\ if  (e_0) \{s_0\}\  else\  \{s_1\}\ \}} \]
where ${\tt s_i}$ are nested programs and $e_i$ are predicates on program
variables.
Note that the result of this transformation is friendlier to the
secure computation setting, since we have reduced the number of loops,
but has introduced a conditional.
Now, consider that $s_0$ and $s_1$ might themselves have conditionals
that can now be flattened into a single conditional with all branches.
By repeatedly applying refactorings like this one, even modest
programs can have conditionals with very high branching factors.

% Let's take this a step further, and consider the following program $P$ still bounded by $T$ total iterations of the inner loops:
% \[{\tt loop_{T_0}\ \{ loop_{T_1} \{ s_0 \};\ s_2;\  loop_{T_2} \{ s_1 \}\ \} }.\] 
% This program can be still be rewritten as  
% \[{\tt loop_{T} \{\ switch  (cond):\{ s_0\ |\ s_1\ |\ s_2\ |\ \mathtt{no-op}\}\ \}},\] 
% saving up to a factor $2T_0\times$ when evaluated with stacked garbling. \vlad{Here I want to add $s_i$ at i-th iteration of outer loop, so that our stacked program will have to have many branches.}

In this work, we do not attempt to systematize the possible SGC-based
optimizations of the generic flow control.
% , but instead provide a
% powerful approach for handling conditionals, even if they have high
% branching factor.
However, we firmly believe that SGC is an essential tool that will
enable research into this direction, and further believe, as argued
above, that performance in the presence of high branching factor is
essential.





 




\subsection{Source of $O(b^2)$ Computation Cost of \HK Stacked Garbling }
\label{sec:bsquaredcost}

It is instructive to explain the source of quadratic SGC computation of \HK, to help explain our work.

At a high level, the fundamental idea of Stacked Garbling is that the evaluator \E
guesses which branch is taken (she in fact tries  all $b$
branches) and evaluates this guessed branch with the appropriately reconstructed material.  Of course, for security, the guess is unverifiable by \E. 
Still, when she guesses right, she indeed evaluates the taken branch and
computes valid GC output labels for that branch.
However, when she guesses wrong, she ends up evaluating the branch
with so-called garbage material (material that is a random-looking string, not
an encryption of circuit truth tables), and ends up computing
\emph{garbage output labels} (i.e., labels that are not the encryption
of $0$ or $1$, but are instead random-looking strings).
%
To proceed past the exit of the conditional and continue garbled evaluation, it is necessary to
`collect'  these garbage labels, i.e., obliviously  discard them in favor of the valid
labels.  (Of course, the final output labels of the conditional will be fresh,  so that they cannot be cross-referenced with those obtained in branch evaluation.)


\HK show how to collect this garbage without
interaction using a 
%.  The main idea is to require SGC Generator \G to construct 
multiplexer garbled gadget, constructed by the SGC Generator \G.  
Building the \HK multiplexer requires \G to {\em know all possible
garbage labels} the evaluator might obtain.  Once this is satisfied, it is easy to see how \G can produce a gadget (e.g., an appropriately wired set of garbled translation tables) eliminating garbage and propagating true values.


{\bf The Uncertainty of \G.}
It is possible for generator to acquire these garbage labels.  \HK achieve this by having \G  emulate the actions of the
evaluator \E on all non-taken branches.  To see how this can be done, let's consider \G's knowledge and uncertainty about the garbled evaluation.  There are three sources of \G's uncertainty:
\begin{itemize}
	\item True values of inputs of all branches.  This is the largest uncertainty (exponential number of possibilities in the number of inputs to the conditional), and the easiest to deal with.  \HK introduce a simple and elegant trick of the circuit simply setting to a fixed value, e.g., all zeros, all the inputs to the inactive branches.  This fully resolves this kind of uncertainty wrt \G.
	\item True index of the actually taken branch, which we denote by \truth.
	\item \E's guess of value of \truth, which we denote by \guess.
\end{itemize}

Thus, there are $b^2$ pairs of labels (including  $b(b-1)$ garbage sets of labels and $b$ valid sets of labels)  that the evaluator
could arrive at: one for each combination of (\truth,\guess), the  actually taken  and
the incorrectly guessed branches. \vlad{is this correct: we have $b$ valid sets of labels?  also call them sets or pairs? decide on notation here.}
%


To aquire all possible garbage labels (and hence build the multiplexer for garbage collection), the \HK generator assumes all-zero inputs for non-taken branches, and emulates ``in its head'' \E's evaluation under all possible (\truth,\guess) combinations.  
% must construct all $b(b-1)$ sets of garbage labels,
This requires \G evaluate GC (i.e. call \Ev) $b(b-1)$ times on garbage material.
This is the source of the $O(b^2)$ computation.



\input{intuition}


\subsection{Our Contributions}
