\section{Introduction}\label{sec:intro}

Secure two party computation (2PC) of arbitrary programs can be
efficiently achieved using garbled circuits (GC).
%
Representing programs as circuits is problematic because conditional
control flow does not have an efficient circuit representation:
in the cleartext program, only the taken execution is computed whereas in
the circuit \emph{all} branches must be computed.
%
Until recently, it was assumed that the players must not only compute
all branches, but also transmit a string of \emph{material}
proportional to all branches.
Since communication is the bottleneck in GC, this large string was
problematic for programs with conditional behavior.

Stacked Garbling~\cite{EPRINT:HeaKol20b} shows that
this expensive communication is unnecessary: the players need only
send enough material for the single longest branch. This single
piece of \emph{stacked} material can be re-used across all conditional branches, thus
dramatically reducing communication cost.
%
This improvement does come with one important downside:
Stacked Garbling requires the players to compute far more than they
would have without stacking.
In particular, the players pay $O(b^2)$ computation where $b$ is the
branching factor.

We briefly explain the source of this added computation.
At a high level, Stacked Garbling requires the evaluator to
``guess'' which branch is taken (she in fact makes all possible
guesses) and evaluates this guessed branch.
When she guesses right, she simply evaluates the taken branch and
computes valid GC output labels for that branch.
However, when she guesses wrong, she ends up evaluating the branch
with so-called garbage material (material that is a random string, not
an encryption of circuit truth tables), and ends up computing
\emph{garbage output labels} (i.e., labels that are not the encryption
of $0$ or $1$, but are instead random strings).
%
To proceed past the exit of the conditional, it is necessary to
`collect' these garbage labels and discard them in favor of the valid
labels.
%
\cite{EPRINT:HeaKol20b} show how to collect this garbage without
interaction, but doing so requires the generator to construct a
garbled gadget called a multiplexer.
Building the multiplexer requires the generator to know all possible
garbage labels the evaluator might construct.
%
It is possible for generator to acquire these garbage labels, but
doing so requires the generator to `emulate' the actions of the
evaluator on all non-taken branches.
It turns out there are $b(b-1)$ garbage label sets that the evaulator
could arrive at: one for each combination of actually taken branch and
incorrectly guessed branch.
%
To build the multiplexer, the generator must construct all $b(b-1)$
sets of garbage labels, requiring him to evaluate $b(b-1)$ circuits
using garbage material.
This is the source of the $O(b^2)$ computation.

In this work, we drive the added computation down from $O(b^2)$ to
$O(b \log b)$.
At a high level, our approach builds on two key ideas:
\begin{enumerate}
  \item The conditional branches are \emph{nested}.
    That is, instead of organizing $b$ branches as a vector, we
    organize them into a binary tree.
    Suppose \E guesses that a particular branch $\cir_i$ is taken,
    while in fact $\cir_j$, a member of a different subtree, is taken.
    The key idea of our approach is that we ensure that when \ev
    garbles the entire subtree containg $\cir_j$ but not $\cir_i$, she
    computes the same material, regardless of $j$.
  \item The multiplexer is \emph{not stacked}.
    The careful reader familiar with \cite{EPRINT:HeaKol20b} may be
    confused about our key idea: Stacked Garbling first presents a
    recursive binary tree approach to branching that they later
    discard in favor of a more efficient vector approach.
    So why is our binary tree approach better?
    The problem with \cite{EPRINT:HeaKol20b}'s recursive construction
    is that the evaluator recursively computes the multiplexer for
    nested sub-conditionals.
    However, doing so leads to a recursive emulation whereby \E
    emulates herself (and hence \G emulates himself as well).
    This recursion leads to quadratic cost for both players.
    The way out is to treat the multiplexer separately, and to opt not
    to stack it.
    If multiplexers are not stacked, then \E need not compute them.
\end{enumerate}


% At a high level, the circuit generator, i.e. the player who constructs
% the material,
