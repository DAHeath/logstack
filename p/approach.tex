\section{Approach}\label{sec:approach}

\begin{figure}
  \begin{adjustwidth}{-0.1\textwidth}{-0.1\textwidth}
  \centering
  \begin{minipage}[t]{0.56\linewidth}
    \begin{align*}
      &\ourscheme.\gev(\cir, \cirinp):\\
      &~~\codecomment{What are the circuit semantics?}\\
      &~~\switch~\cir:\\
      &~~~~\ccase~\netlist(\cdot): \creturn~\underscheme.\gev(\cir, \cirinp)\\
      &~~~~\ccase~\sequential(\cir_0, \cir_1):
      \creturn~\ourscheme.\gev(\cir_1, \ourscheme.\gev(\cir_0,
      \cirinp))\\
      &~~~~\ccase~\conditional(\vec{\cir}):\\
      &~~~~~~\codecomment{split branch index from input}\\
      &~~~~~~\aid \gets \cirinp[0..\log |\vec \cir|]\\
      &~~~~~~\cirinp' \gets \cirinp[\log |\vec \cir|..]\\
      &~~~~~~\codecomment{Run the active branch.}\\
      &~~~~~~\creturn~\ourscheme.\gev(\vec{\cir}[\aid], \cirinp')\\
      \\
      &\ourscheme.\gEv(\cir,\mat,\gcirinp):\\
      &~~\codecomment{How does \E evaluate the GC?}\\
      &~~\switch(\cir):\\
      &~~~~\ccase~\netlist(\cdot): \creturn~\underscheme.\gEv(\cir,\mat,\gcirinp)\\
      &~~~~\ccase~\sequential(\cir_0, \cir_1): \\
      &~~~~~~\mat_0\mid\mat_{tr}\mid\mat_1 \gets \mat\\
      &~~~~~~\creturn~\ourscheme.\gEv(\cir_1, \mat_1, \evtranslate(\ourscheme.\gEv(\cir_0, \mat_0, \cirinp), \mat_{tr})\\
      &~~~~\ccase~\conditional(\vec \cir): \creturn~\evcond(\vec \cir,
      \mat, \gcirinp)\\
      \\
      &\ourscheme.\gEn(e,\cirinp):\\
      &~~\codecomment{How do inputs map to labels?}\\
      &~~\codecomment{This works for all projective schemes:}\\
      &~~\gcirinp \gets \emptystring\\
      &~~\cfor~i \in 0..n\minus 1:\\
      &~~~~(X^0, X^1) \gets e[i]\\
      &~~~~\cif~\cirinp[i] = 0:~\{~\gcirinp[i] \gets X^0~\}~\celse:~\{~\gcirinp[i] \gets X^1~\}\\
      &~~\creturn~\gcirinp
    \end{align*}
  \end{minipage}
  %
  \begin{minipage}[t]{0.40\linewidth}
    \begin{align*}
      &\ourscheme.\gGb(1^\kappa, \cir, S)\\
      &~~\codecomment{How does \G garble the GC?}\\
      &~~\switch~\cir:\\
      &~~~~\ccase~\netlist(\cdot):\\
      &~~~~~~\creturn~\underscheme.\gGb(1^\kappa,\cir,S)\\
      &~~~~\ccase~\sequential(\cir_0, \cir_1):\\
      &~~~~~~(\mat_0, e_0, d_0) \gets \ourscheme.\gGb(1^\kappa,\cir_0, S)\\
      &~~~~~~(\mat_1, e_1, d_1) \gets \ourscheme.\gGb(1^\kappa,\cir_1, S)\\
      &~~~~~~\codecomment{Labels out of $\cir_0$ must be \emph{translated}}\\
      &~~~~~~\codecomment{to labels into $\cir_1$.}\\
      &~~~~~~\mat_{tr} \gets \gbtranslate(d_0,e_1)\\
      &~~~~~~\mat \gets \mat_0\mid \mat_{tr}\mid \mat_1\\
      &~~~~~~\creturn~(\mat, e_0, d_1)\\
      &~~~~\ccase~\conditional(\vec \cir): \creturn~\gbcond(\vec \cir)\\
      \\
      &\ourscheme.\gDe(d, \gcirout):\\
      &~~\codecomment{How do labels map to outputs?}\\
      &~~\codecomment{This works for all projective schemes:}\\
      &~~\cirout \gets \lambda\\
      &~~\cfor~i \in 0.. m\minus 1:\\
      &~~~~(Y^0, Y^1) \gets d[i]\\
      &~~~~\cif~\gcirout[i] = Y^0:~\cirout[i] \gets 0\\
      &~~~~\celse~\cif~\gcirout[i] = Y^1:~\cirout[i] \gets 1\\
      &~~~~\celse:~\mathtt{ABORT}\\
      &~~\creturn~\cirout
      % &\genprojection(n, S):\\
      % &~~p \gets \lambda\\
      % &~~\cfor~i \in 0..n\minus 1:\\
      % &~~~~X^0 \drawnfrom{S} \{0, 1\}^{\kappa}\\
      % &~~~~X^1 \drawnfrom{S} \{0, 1\}^{\kappa}\\
      % &~~~~c \drawnfrom{S} \{0, 1\}\\
      % &~~~~p \gets p \mid ((X^0\mid c), (X^1\mid \xor{1}{c}))\\
      % &~~\creturn~p
    \end{align*}
  \end{minipage}
  \end{adjustwidth}
  \caption{%
    Our garbling scheme \ourschemelong.
    The included algorithms are typical except for the handling of
    conditionals.
    \gEv\ and \gGb\ delegate the core of our approach to
    the delegation to
    \evcond\ and \gbcond\ respectively.
  }\label{fig:scheme}
\end{figure}

\begin{figure}
  \begin{align*}
    &\func_\gadget(\vec S):\\
    &~~\codecomment{delegate to a recursive subprocedure}\\
    &~~\codecomment{the root of the overall tree is always an ancestor
    of \aid}\\
    &~~\creturn~\func_\gadget'(\vec S, 1)\\
    \\
    &\func_\gadget'(\vec S, isAncestor):\\
    &~~\codecomment{$isAncestor$ indicates if the current node is an ancestor of \aid}\\
    &~~\cif~empty(\vec S):\\
    &~~~~\codecomment{when we reach the bottom of the tree, no
    seeds are needed}\\
    &~~~~\creturn~[~]\\
    &~~\celse:\\
    &~~~~\codecomment{split the index $\vec S$ into the first bit and
    the remaining bits}\\
    &~~~~S \gets \vec S[0]\\
    &~~~~\vec S' \gets \vec S[1..]\\
    &~~~~isSR_l \gets isAncestor\cdot S \quad\codecomment{is the left
    child a sibling root of \aid?}\\
    &~~~~isSR_r \gets isAncestor\cdot \neg S \quad \codecomment{is the
    right child a sibling root of \aid?}\\
    &~~~~s_l \gets toSeed(isSR_l)\\
    &~~~~s_r \gets toSeed(isSR_r)\\
    &~~~~\codecomment{recursively step to children and compute remaining seeds}.\\
    &~~~~\codecomment{if right child is a sibling root of \aid,
    then left child is an ancestor of \aid}\\
    &~~~~\vec s_l \gets \func_\gadget'(\vec S', isSR_r)\\
    &~~~~\vec s_r \gets \func_\gadget'(\vec S', isSR_l)\\
    &~~~~\codecomment{concatenate all partial results into one
    vector}\\
    &~~~~\creturn~s_l \mid \vec s_l\mid  s_r\mid  \vec s_r\\
    \\
    &toSeed(isSR_\node) = 
    \begin{cases}
        s_\node,& \text{if } isSR_\node\\
        s_\node',& \text{otherwise}
    \end{cases}
  \end{align*}
  \caption{%
    The functionality for the garbled gadget \gadget, $\func_\gadget$.
    $\func_\gadget$ computes for \E a vector of the needed seeds for her
    evaluation of the conditional circuit. For each sibling root \node of
    the active branch \aid, $\func_\gadget$ outputs the correct seed
    $s_\node$. For the remaining nodes, $\func_\gadget$ outputs
    $s'_\node$, an incorrect seed.
    %
    As presented, $\func_\gadget$ is for a complete binary tree.
    $\func_\gadget$ is easily realized as a garbled circuit.
  }\label{fig:gadget-func}
\end{figure}

\begin{figure}
  \begin{align*}
    &\gbtree(\vec{\cir}, i, j, es):\\
    &~~\codecomment{$es$ refers to \E's seed for the node $\node_{i,j}$.}\\
    &~~\codecomment{\G also invokes this procedure, but does so to emulate \E.}\\
    &~~\cif~i = j:\\
    &~~~~\codecomment{Base case of $1$ branch.}\\
    &~~~~M, \cdot, \cdot \gets \gb(\vec\cir[i], es)\\
    &~~~~\creturn~M\\
    &~~\celse:\\
    &~~~~\codecomment{Expand child seeds using PRF.}\\
    &~~~~es_L \gets F_{es}(0)\\
    &~~~~es_R \gets F_{es}(1)\\
    &~~~~\codecomment{Recursively garble both child trees and stack
    material.}\\
    &~~~~\creturn~\gbtree(\vec{\cir}, i, \sfrac{j}{2}, es_L) \oplus
    \gbtree(\vec{\cir}, \sfrac{j}{2} + 1, j, es_R)\\
  \end{align*}
  \caption{%
    The helper algorithm \gbtree\ uses a single seed to recursively
    garble all circuits $\cir_i - \cir_j$ and stacks (using XOR) all
    resultant material.
  }
\end{figure}

\begin{figure}
  \begin{align*}
    &\evcond(\vec{\cir}, \mat, X):\\
    &~~b \gets | \vec{\cir} |\\
    &~~\codecomment{Split the active branch index from the rest of the
    input.}\\
    &~~\aid \mid X' \gets X\\
    &~~\codecomment{Split material up for gadgets and body of conditional.}\\
    &~~\mat_\gadget \mid \mat_{dem} \mid \mat_{cond} \mid \mat_{mux} \gets \mat\\
    &~~\codecomment{Run $\gadget$ to compute all of \E's seeds.}\\
    &~~es \gets \gadget.\mathtt{Ev}(\aid, \mat_\gadget)\\
    &~~\codecomment{Run the demultiplexer to compute input for each branch $\cir_i$}\\
    &~~\vec{X} \gets \evdem(\aid, X, \mat_{dem})\\
    &~~\codecomment{We define a recursive subprocedure that evaluates $\cir_i - \cir_j$ using material $\mat$.}\\
    &~~\evcond'(\mat, i, j):\\
    &~~~~\cif~i = j:\\
    &~~~~~~\codecomment{Base case: compute output by evaluating the branch normally.}\\
    &~~~~~~\gcirout_i \gets \ev(\cir_i, M, \gcirinp_i)\\
    &~~~~\celse:\\
    &~~~~~~\codecomment{Garble the right subtree using the available
    seed,}\\
    &~~~~~~\codecomment{unstack, and recursively evaluate the left
    subtree.}\\
    &~~~~~~\mat_R \gets \gbtree(\vec{\cir}, \sfrac{j}{2}+1, j, es_{\sfrac{j}{2}+1, j})\\
    &~~~~~~\evcond'(\mat \oplus \mat_R, i, \sfrac{j}{2})\\
    &~~~~~~\codecomment{Symmetrically evaluate the right subtree.}\\
    &~~~~~~\mat_L \gets \gbtree(\vec{\cir}, i, \sfrac{j}{2}, es_{i,\sfrac{j}{2}})\\
    &~~~~~~\evcond'(\mat \oplus \mat_L, \sfrac{j}{2}+1, j)\\
    &~~\codecomment{Start recursive process from the top of the tree.}\\
    &~~\evcond'(M_{cond}, 0, b-1)\\
    &~~\codecomment{Eliminate garbage and propagate $\vec{Y}_\aid$ via
    the multiplexer.}\\
    &~~\creturn~\evmux(\aid, \vec{Y}, M_{mux})
  \end{align*}
  \caption{%
    \E's procedure, \evcond, for evaluating a conditional with $b$ branches.
    \evcond\ recursively evaluates each branch; $b-1$ evaluations
    result in garbage outputs and $1$ (specifically the evaluation of
    $\cir_\aid$) results in valid outputs.
    The multiplexer collects garbage and propagates output from
    $\cir_\aid$.
  }
\end{figure}


\begin{figure}
  \begin{align*}
    &\gbcond(\vec{\cir}, S):\\
    &~~b \gets | \vec{\cir} |\\
    &~~\codecomment{Recursively derive all `good' seeds for the entire tree.}\\
    &~~s \gets \mathtt{DeriveSeedTree}(S)\\
    &~~\codecomment{Uniformly sample an input encoding for the conditional.}\\
    &~~e \gets \mathtt{UniformEncoding}(S)\\
    &~~\codecomment{Split encoding into encoding of active branch
    index and rest of encoding.}\\
    &~~e_\aid, e' \gets e\\
    &~~\codecomment{Garble \gadget\ based on the encoding of \aid.}\\
    &~~\codecomment{This outputs material as well as the tree of all
    `bad' seeds $s'$.}\\
    &~~\mat_\gadget, s' \gets \gadget.\mathtt{Gb}(e_\aid, s)\\
    &~~\mat_{dem}, \bot_{in} \gets \gbdem(e_\aid, e')\\
    &~~\codecomment{We define a recursive subprocedure that garbles $\cir_i - \cir_j$.}\\
    &~~\gbcond'(i, j, \vec{\mat}):\\
    &~~~~\codecomment{Recursively garble $\cir_i - \cir_j$ \emph{and}
    compute all possible garbage outputs.}\\
    &~~~~\codecomment{$\vec{\mat}$ is a vector of the bad garblings of
      all sibling roots of the current node.}\\
    &~~~~\cif~i = j:\\
    &~~~~~~\mat, \cdot, \vec{d}_i \gets \gb(\vec{\cir}[i], s_{i})\\
    &~~~~~~acc \gets \mat\\
    &~~~~~~\cfor~k \in 0..|\log b|:\\
    &~~~~~~~~\codecomment{Emulate all possible bad evaluations of $\cir_i$.}\\
    &~~~~~~~~acc \gets acc \oplus \vec{\mat}[k]\\
    &~~~~~~~~\bot_{out}[i][k] \gets \mid \gEv(\vec{\cir}[i], acc,
    \bot_{in}[k])\\
    &~~~~~~\creturn~M\\
    &~~~~\celse:\\
    &~~~~~~\mat_R \gets \gbtree(\vec{\cir}, \sfrac{j}{2}+1, j, s_{\sfrac{j}{2}+1, j})\\
    &~~~~~~\mat_R' \gets \gbtree(\vec{\cir}, \sfrac{j}{2}+1, j, s'_{\sfrac{j}{2}+1, j})\\
    &~~~~~~\mat_L \gets \gbcond'(i, \sfrac{j}{2}, (\mat_R \oplus \mat_R') \mid \vec{\mat})\\
    &~~~~~~\mat_L' \gets \gbtree(\vec{\cir}, i, \sfrac{j}{2}, s'_{i, \sfrac{j}{2}})\\
    &~~~~~~\cdot \gets \gbcond'(\sfrac{j}{2}+1, j, (\mat_L \oplus \mat_L') \mid \vec{\mat})\\
    &~~~~~~\creturn~\mat_L \oplus \mat_R\\
    &~~\mat_{cond} \gets \gbcond'(0, b-1, [~])\\
    &~~\mat_{mux} \gets \gbmux(e_\aid, d, \vec{d}, \bot_{out})\\
    &~~\creturn~(\mat_\gadget \mid \mat_{dem} \mid \mat_{cond} \mid \mat_{mux}, e, d)
  \end{align*}
  \caption{%
    The algorithm for garbling a conditional vector.
    Given $b$ branches, \gbcond returns (1) the stacked material, (2)
    the input encoding string, (3) all $b$ output decoding strings,
    and (4) all $b\log b$ possible garbage output label vectors.
  }
\end{figure}
