\section{Approach}\label{sec:approach}
In this section, we formalize our construction, \ourschemelong.
Throughout this section, consider a circuit with a conditional with $b$
branches.
For simplicity of discussion, we ignore the number input and output
wires and consider branches with a fixed constant number of gates.

We adopt the above restriction because branching factor is the most interesting
aspect of \ourschemelong. We emphasize that ignoring inputs/outputs
and fixing the number of gates does not hide high costs.
\ourschemelong scales linearly with the number of gates per branch.
While we scale with the product of the number of inputs and $b$ (and
respectively the product of number of outputs and $b$), the
constants are very low.
See \Cref{sec:eval} for evidence of these low constants.

Given that we consider only the branching factor $b$, \ourschemelong\ features:
\begin{itemize}
  \item $O(1)$ communication complexity.
  \item $O(b \log b)$ time complexity.
  \item $O(\log b)$ space complexity.
\end{itemize}

In this section, we formalize our algorithms and give proofs of the above
complexities. We postpone proofs of correctness and security to
\Cref{sec:proof}.

\ourschemelong\ is formalized as a \emph{garbling
scheme}~\cite{CCS:BelHoaRog12}.
Garbling schemes abstract the details of GC such that protocols can be written generically.
More precisely, our formalization uses the modified garbling scheme
framework of \HK, which separates the \emph{topology} of circuits
(i.e., the concrete circuit description) from circuit material
(i.e., the collections of encryptions needed to securely evaluate the
circuit), an important modification for SGC.

A garbling scheme is a tuple of five algorithms:
\[ (\gev, \gEv, \gGb, \gEn, \gDe) \]
%
\begin{itemize}
  \item \gev\ specifies circuit semantics. For typical approaches that
    consider only low-level gates, \gev\ is usually not formalized since its
    implementation is implicitly understood by the community. We explicate \gev\ to formalize
    conventions of conditional evaluation.
  \item \gEv\ specifies how \E\ securely evaluates the GC.
  \item \gGb\ specifies how \G\ garbles the GC.
  \item \gEn\ and \gDe\ specify the translation of cleartext values
    to/from GC labels. That is, \gEn\ specifies how player
    inputs translate to input labels and \gDe\ specifies how outputs
    labels translate to cleartext outputs.
\end{itemize}
%
Correct garbling schemes ensure that the garbled functions \gGb, \gEn,
\gEv, and \gDe\ achieve the semantics specified by \gev.

Before we present our garbling scheme \ourschemelong, we introduce the
formal syntax of the circuits it manipulates.
Because our focus is conditional branching, we assume the existence of
an \emph{underlying garbling scheme} \underscheme.
\underscheme\ is responsible for handling the collections of low level
gates (typically AND and XOR gates) that we refer to as \emph{netlists}.
In our implementation, we instantiate \underscheme\ with the efficient
half-gates scheme~\cite{EC:ZahRosEva15}.
We do not specify the syntax of netlists, and entirely leave their
handling to \underscheme.
Our circuit syntax is defined inductively:
Let $\cir_0, \cir_1$ be two arbitrary circuits and $\vec \cir$ be an
arbitrary vector of circuits. The space of
circuits is defined as follows:
\[
  \cir ::= \netlist(\cdot)~|~%
  \conditional(\vec \cir)~|~%
  \sequential(\cir_0, \cir_1)
\]

That is, a circuit is either (1) a netlist, (2) a conditional dispatch
over a vector of circuits (our focus), or (3) a sequence of two
circuits.
We note that sequences of circuits are necessary to allow arbitrary
control flow.


\begin{figure}
  \begin{adjustwidth}{-0.1\textwidth}{-0.1\textwidth}
  \centering
  \begin{minipage}[t]{0.56\linewidth}
    \begin{align*}
      &\ourscheme.\gev(\cir, \cirinp):\\
      &~~\codecomment{What are the circuit semantics?}\\
      &~~\switch~\cir:\\
      &~~~~\ccase~\netlist(\cdot): \creturn~\underscheme.\gev(\cir, \cirinp)\\
      &~~~~\ccase~\sequential(\cir_0, \cir_1):
      \creturn~\ourscheme.\gev(\cir_1, \ourscheme.\gev(\cir_0,
      \cirinp))\\
      &~~~~\ccase~\conditional(\vec{\cir}):\\
      &~~~~~~\codecomment{split branch index from input}\\
      &~~~~~~\aid \gets \cirinp[0..\log |\vec \cir|]\\
      &~~~~~~\cirinp' \gets \cirinp[\log |\vec \cir|..]\\
      &~~~~~~\codecomment{Run the active branch.}\\
      &~~~~~~\creturn~\ourscheme.\gev(\vec{\cir}[\aid], \cirinp')\\
      \\
      &\ourscheme.\gEv(\cir,\mat,\gcirinp):\\
      &~~\codecomment{How does \E evaluate the GC?}\\
      &~~\switch(\cir):\\
      &~~~~\ccase~\netlist(\cdot): \creturn~\underscheme.\gEv(\cir,\mat,\gcirinp)\\
      &~~~~\ccase~\sequential(\cir_0, \cir_1): \\
      &~~~~~~\mat_0\mid\mat_{tr}\mid\mat_1 \gets \mat\\
      &~~~~~~\creturn~\ourscheme.\gEv(\cir_1, \mat_1, \evtranslate(\ourscheme.\gEv(\cir_0, \mat_0, \cirinp), \mat_{tr})\\
      &~~~~\ccase~\conditional(\vec \cir): \creturn~\evcond(\vec \cir,
      \mat, \gcirinp)\\
      \\
      &\ourscheme.\gEn(e,\cirinp):\\
      &~~\codecomment{How do inputs map to labels?}\\
      &~~\codecomment{This works for all projective schemes:}\\
      &~~\gcirinp \gets \emptystring\\
      &~~\cfor~i \in 0..n\minus 1:\\
      &~~~~(X^0, X^1) \gets e[i]\\
      &~~~~\cif~\cirinp[i] = 0:~\{~\gcirinp[i] \gets X^0~\}~\celse:~\{~\gcirinp[i] \gets X^1~\}\\
      &~~\creturn~\gcirinp
    \end{align*}
  \end{minipage}
  %
  \begin{minipage}[t]{0.40\linewidth}
    \begin{align*}
      &\ourscheme.\gGb(1^\kappa, \cir, S)\\
      &~~\codecomment{How does \G garble the GC?}\\
      &~~\switch~\cir:\\
      &~~~~\ccase~\netlist(\cdot):\\
      &~~~~~~\creturn~\underscheme.\gGb(1^\kappa,\cir,S)\\
      &~~~~\ccase~\sequential(\cir_0, \cir_1):\\
      &~~~~~~(\mat_0, e_0, d_0) \gets \ourscheme.\gGb(1^\kappa,\cir_0, S)\\
      &~~~~~~(\mat_1, e_1, d_1) \gets \ourscheme.\gGb(1^\kappa,\cir_1, S)\\
      &~~~~~~\codecomment{Labels out of $\cir_0$ must be \emph{translated}}\\
      &~~~~~~\codecomment{to labels into $\cir_1$.}\\
      &~~~~~~\mat_{tr} \gets \gbtranslate(d_0,e_1)\\
      &~~~~~~\mat \gets \mat_0\mid \mat_{tr}\mid \mat_1\\
      &~~~~~~\creturn~(\mat, e_0, d_1)\\
      &~~~~\ccase~\conditional(\vec \cir): \creturn~\gbcond(\vec \cir)\\
      \\
      &\ourscheme.\gDe(d, \gcirout):\\
      &~~\codecomment{How do labels map to outputs?}\\
      &~~\codecomment{This works for all projective schemes:}\\
      &~~\cirout \gets \lambda\\
      &~~\cfor~i \in 0.. m\minus 1:\\
      &~~~~(Y^0, Y^1) \gets d[i]\\
      &~~~~\cif~\gcirout[i] = Y^0:~\cirout[i] \gets 0\\
      &~~~~\celse~\cif~\gcirout[i] = Y^1:~\cirout[i] \gets 1\\
      &~~~~\celse:~\mathtt{ABORT}\\
      &~~\creturn~\cirout
      % &\genprojection(n, S):\\
      % &~~p \gets \lambda\\
      % &~~\cfor~i \in 0..n\minus 1:\\
      % &~~~~X^0 \drawnfrom{S} \{0, 1\}^{\kappa}\\
      % &~~~~X^1 \drawnfrom{S} \{0, 1\}^{\kappa}\\
      % &~~~~c \drawnfrom{S} \{0, 1\}\\
      % &~~~~p \gets p \mid ((X^0\mid c), (X^1\mid \xor{1}{c}))\\
      % &~~\creturn~p
    \end{align*}
  \end{minipage}
  \end{adjustwidth}
  \caption{%
    Our garbling scheme \ourschemelong.
    The included algorithms are typical except for the handling of
    conditionals.
    \gEv\ and \gGb\ delegate the core of our approach to
    the delegation to
    \evcond\ and \gbcond\ respectively.
  }\label{fig:scheme}
\end{figure}


With our syntax established, we are ready to present our algorithms.
\begin{construction}[\ourschemelong]
  \ourschemelong\ is the tuple of algorithms:
  \[ (\ourscheme.\gev, \ourscheme.\gEv, \ourscheme.\gGb, \ourscheme.\gEn, \ourscheme.\gDe) \]
  Definitions for each algorithm are listed in \Cref{fig:scheme}.
\end{construction}
We draw attention to two key details of these algorithms:
(1) $\ourscheme.\gEv$ delegates to a subprocedure \evcond\ and (2)
$\ourscheme.\gGb$ delegates to a subprocedure \gbcond.
%
All details of conditionals are handled by these two subprocedures.
%
Aside from these delegations, the algorithms in \Cref{fig:scheme} are
relatively uninteresting, but are given for completeness.
We briefly discuss these less interesting algorithms before returning
to an extended discussion of \evcond\ and
\gbcond~(c.f. \Cref{sec:approach-cond}).

\begin{itemize}
  \item \textbf{Projectivity.} \ourschemelong\
    is a \emph{projective garbling scheme}~\cite{CCS:BelHoaRog12}.
    This stronger definition requires that the input \emph{encoding string}
    $e$ and output \emph{decoding string} $d$ have a specific format:
    they must both be a vector of pairs of labels such that the left
    element of each pair is a label encoding logical $0$ and the right
    element of each pair is a label encoding logical $1$.
    Thus, $\ourscheme.\gEn$ and $\ourscheme.\gDe$ are straightforward
    mappings between cleartext values and encoding/decoding strings.
  \item \textbf{Delegation to \underscheme.} Note that
    $\ourscheme.\gev$, $\ourscheme.\gEv$, and $\ourscheme.\gDe$ indeed
    directly delegate to \underscheme\ in the cast of a netlist.
  \item \textbf{Sequences and Translation.} In a sequence of two
    circuits, all output wires of the first circuit are past as the inputs
    to the second. However, these two circuits are garbled completely
    independently (i.e., starting from different seeds). Thus, a
    priori the output labels from $\cir_0$ will not match the required
    input encoding of $\cir_1$.
    %
    We thus implement a \emph{translation} component ($\evtranslate$
    and $\gbtranslate$) that implements via garbled rows
    straightforward translation from one encoding to another.
\end{itemize}

\subsection{Algorithms for Handling of Conditionals}\label{sec:approach-cond}

\begin{figure}
  \begin{align*}
    &\gbtree(\vec{\cir}, i, j, seed):\\
    &~~\cif~i = j:\\
    &~~~~\codecomment{Base case of $1$ branch.}\\
    &~~~~M, \cdot, \cdot \gets \gb(\vec\cir[i], seed)\\
    &~~~~\creturn~M\\
    &~~\celse:\\
    &~~~~\codecomment{Expand child seeds using PRF.}\\
    &~~~~seed_L \gets F_{seed}(0)\\
    &~~~~seed_R \gets F_{seed}(1)\\
    &~~~~\codecomment{Recursively garble both child trees and stack
    material.}\\
    &~~~~\creturn~\gbtree(\vec{\cir}, i, \sfrac{j}{2}, seed_L) \oplus
    \gbtree(\vec{\cir}, \sfrac{j}{2} + 1, j, seed_R)\\
  \end{align*}
  \caption{%
    The helper algorithm \gbtree\ uses a single seed to recursively
    garble all circuits $\cir_i - \cir_j$ and stacks (using XOR) all
    resultant material.
  }\label{fig:gbtree}
\end{figure}

With the remaining formalization out of the way, we focus specifically
on conditional branching. Our specific goal is to formalize \evcond\
and \gbcond.
We start by defining a simpler procedure, \gbtree~(\Cref{fig:gbtree}),
which is a crucial ingredient for both \evcond\ and \gbcond.
Recall from our technical overview (\Cref{sec:techOverview}) that we
organized the $b$ branches into a binary branching tree.
%
Indeed, we use this same organization in our formalization.
\gbtree\ formalizes the process by which both players
garble entire subtrees of branches starting from a single seed.
Specifically, \gbtree\ recursively descends through the
tree, using a PRF to derive child seeds from the parent seed, and at the
leaves garbles the branches.
As the recursion propagates back up the tree, the procedure stacks the
garblings together.
%
As it recursively descends, this algorithm tracks two integers $i$ and
$j$, denoting the range of branches circuits $\cir_i - \cir_j$ that are to
be stacked together.
Our other algorithms use a similar strategy, and all such algorithms
maintain an invariant that $i,j$ refers to a valid node in the binary
branching tree over the $b$ branches.


We note two trivial properties of \gbtree, recalling that we ignore
the number of inputs/outputs and consider branches of constant size.
First, it is immediate that \gbtree\ runs in linear time:
\begin{lemma}\label{lemma:gbtreetime}
  For all vectors of circuits $\vec \cir$, all $i, j \in \mathbb{N}$
  such that $i \leq j$, and all $seed \in \{0, 1\}^\kappa$,
  $\gbtree(\vec \cir, i, j, seed)$ invokes $\gGb$ $j - i + 1$ times.
\end{lemma}
In other words, the algorithm garbles each branch once.

\begin{lemma}\label{lemma:gbtreetime}
  For all vectors of circuits $\vec \cir$, all $i, j \in \mathbb{N}$
  such that $i \leq j$, and all $seed \in \{0, 1\}^\kappa$,
  $\gbtree(\vec \cir, i, j, seed)$ runs in $O(1)$ space.
\end{lemma}
\begin{proof}
Immediate from the fact that (1) the leaves yield a single garbling
and (2) the inner tree nodes eagerly stack material together.
\end{proof}

\begin{figure}
  \begin{align*}
    &\evcond(\vec{\cir}, \mat, X):\\
    &~~b \gets | \vec{\cir} |\\
    &~~\codecomment{Split the active branch index from the rest of the
    input.}\\
    &~~\aid \mid X' \gets X\\
    &~~\codecomment{Split material up for gadgets and body of conditional.}\\
    &~~\mat_\gadget \mid \mat_{dem} \mid \mat_{cond} \mid \mat_{mux} \gets \mat\\
    &~~\codecomment{Run $\gadget$ to compute all of \E's seeds.}\\
    &~~es \gets \gadget.\mathtt{Ev}(\aid, \mat_\gadget)\\
    &~~\codecomment{Run the demultiplexer to compute input for each branch $\cir_i$}\\
    &~~\vec{X} \gets \evdem(\aid, X, \mat_{dem})\\
    &~~\codecomment{We define a recursive subprocedure that evaluates $\cir_i - \cir_j$ using material $\mat$.}\\
    &~~\evcond'(\mat, i, j):\\
    &~~~~\cif~i = j:\\
    &~~~~~~\codecomment{Base case: compute output by evaluating the branch normally.}\\
    &~~~~~~\gcirout_i \gets \ev(\cir_i, M, \gcirinp_i)\\
    &~~~~\celse:\\
    &~~~~~~\codecomment{Garble the right subtree using the available
    seed,}\\
    &~~~~~~\codecomment{unstack, and recursively evaluate the left
    subtree.}\\
    &~~~~~~\mat_R \gets \gbtree(\vec{\cir}, \sfrac{j}{2}+1, j, es_{\sfrac{j}{2}+1, j})\\
    &~~~~~~\evcond'(\mat \oplus \mat_R, i, \sfrac{j}{2})\\
    &~~~~~~\codecomment{Symmetrically evaluate the right subtree.}\\
    &~~~~~~\mat_L \gets \gbtree(\vec{\cir}, i, \sfrac{j}{2}, es_{i,\sfrac{j}{2}})\\
    &~~~~~~\evcond'(\mat \oplus \mat_L, \sfrac{j}{2}+1, j)\\
    &~~\codecomment{Start recursive process from the top of the tree.}\\
    &~~\evcond'(M_{cond}, 0, b-1)\\
    &~~\codecomment{Eliminate garbage and propagate $\vec{Y}_\aid$ via
    the multiplexer.}\\
    &~~\creturn~\evmux(\aid, \vec{Y}, M_{mux})
  \end{align*}
  \caption{%
    \E's procedure, \evcond, for evaluating a conditional with $b$ branches.
    \evcond\ recursively evaluates each branch; $b-1$ evaluations
    result in garbage outputs and $1$ (specifically the evaluation of
    $\cir_\aid$) results in valid outputs.
    The multiplexer collects garbage and propagates output from
    $\cir_\aid$.
  }
\end{figure}


\begin{figure}
  \begin{align*}
    &\gbcond(\vec{\cir}, S):\\
    &~~b \gets | \vec{\cir} |\\
    &~~\codecomment{Recursively derive all `good' seeds for the entire tree.}\\
    &~~s \gets \mathtt{DeriveSeedTree}(S)\\
    &~~\codecomment{Uniformly sample an input encoding for the conditional.}\\
    &~~e \gets \mathtt{UniformEncoding}(S)\\
    &~~\codecomment{Split encoding into encoding of active branch
    index and rest of encoding.}\\
    &~~e_\aid, e' \gets e\\
    &~~\codecomment{Garble \gadget\ based on the encoding of \aid.}\\
    &~~\codecomment{This outputs material as well as the tree of all
    `bad' seeds $s'$.}\\
    &~~\mat_\gadget, s' \gets \gadget.\mathtt{Gb}(e_\aid, s)\\
    &~~\mat_{dem}, \bot_{in} \gets \gbdem(e_\aid, e')\\
    &~~\codecomment{We define a recursive subprocedure that garbles $\cir_i - \cir_j$.}\\
    &~~\gbcond'(i, j, \vec{\mat}):\\
    &~~~~\codecomment{Recursively garble $\cir_i - \cir_j$ \emph{and}
    compute all possible garbage outputs.}\\
    &~~~~\codecomment{$\vec{\mat}$ is a vector of the bad garblings of
      all sibling roots of the current node.}\\
    &~~~~\cif~i = j:\\
    &~~~~~~\mat, \cdot, \vec{d}_i \gets \gb(\vec{\cir}[i], s_{i})\\
    &~~~~~~acc \gets \mat\\
    &~~~~~~\cfor~k \in 0..|\log b|:\\
    &~~~~~~~~\codecomment{Emulate all possible bad evaluations of $\cir_i$.}\\
    &~~~~~~~~acc \gets acc \oplus \vec{\mat}[k]\\
    &~~~~~~~~\bot_{out}[i][k] \gets \mid \gEv(\vec{\cir}[i], acc,
    \bot_{in}[k])\\
    &~~~~~~\creturn~M\\
    &~~~~\celse:\\
    &~~~~~~\mat_R \gets \gbtree(\vec{\cir}, \sfrac{j}{2}+1, j, s_{\sfrac{j}{2}+1, j})\\
    &~~~~~~\mat_R' \gets \gbtree(\vec{\cir}, \sfrac{j}{2}+1, j, s'_{\sfrac{j}{2}+1, j})\\
    &~~~~~~\mat_L \gets \gbcond'(i, \sfrac{j}{2}, (\mat_R \oplus \mat_R') \mid \vec{\mat})\\
    &~~~~~~\mat_L' \gets \gbtree(\vec{\cir}, i, \sfrac{j}{2}, s'_{i, \sfrac{j}{2}})\\
    &~~~~~~\cdot \gets \gbcond'(\sfrac{j}{2}+1, j, (\mat_L \oplus \mat_L') \mid \vec{\mat})\\
    &~~~~~~\creturn~\mat_L \oplus \mat_R\\
    &~~\mat_{cond} \gets \gbcond'(0, b-1, [~])\\
    &~~\mat_{mux} \gets \gbmux(e_\aid, d, \vec{d}, \bot_{out})\\
    &~~\creturn~(\mat_\gadget \mid \mat_{dem} \mid \mat_{cond} \mid \mat_{mux}, e, d)
  \end{align*}
  \caption{%
    The algorithm for garbling a conditional vector.
    Given $b$ branches, \gbcond returns (1) the stacked material, (2)
    the input encoding string, (3) all $b$ output decoding strings,
    and (4) all $b\log b$ possible garbage output label vectors.
  }
\end{figure}
