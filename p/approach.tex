\section{Approach}\label{sec:approach}

\begin{figure}
  \begin{align*}
    &\func_\gadget(\vec S):\\
    &~~\codecomment{delegate to a recursive subprocedure}\\
    &~~\codecomment{the root of the overall tree is always an ancestor
    of \aid}\\
    &~~\creturn~\func_\gadget'(\vec S, 1)\\
    \\
    &\func_\gadget'(\vec S, isAncestor):\\
    &~~\codecomment{$isAncestor$ indicates if the current node is an ancestor of \aid}\\
    &~~\cif~empty(\vec S):\\
    &~~~~\codecomment{when we reach the bottom of the tree, no
    seeds are needed}\\
    &~~~~\creturn~[~]\\
    &~~\celse:\\
    &~~~~\codecomment{split the index $\vec S$ into the first bit and
    the remaining bits}\\
    &~~~~S \gets \vec S[0]\\
    &~~~~\vec S' \gets \vec S[1..]\\
    &~~~~isSR_l \gets isAncestor\cdot S \quad\codecomment{is the left
    child a sibling root of \aid?}\\
    &~~~~isSR_r \gets isAncestor\cdot \neg S \quad \codecomment{is the
    right child a sibling root of \aid?}\\
    &~~~~s_l \gets toSeed(isSR_l)\\
    &~~~~s_r \gets toSeed(isSR_r)\\
    &~~~~\codecomment{recursively step to children and compute remaining seeds}.\\
    &~~~~\codecomment{if right child is a sibling root of \aid,
    then left child is an ancestor of \aid}\\
    &~~~~\vec s_l \gets \func_\gadget'(\vec S', isSR_r)\\
    &~~~~\vec s_r \gets \func_\gadget'(\vec S', isSR_l)\\
    &~~~~\codecomment{concatenate all partial results into one
    vector}\\
    &~~~~\creturn~s_l \mid \vec s_l\mid  s_r\mid  \vec s_r\\
    \\
    &toSeed(isSR_\node) = 
    \begin{cases}
        s_\node,& \text{if } isSR_\node\\
        s_\node',& \text{otherwise}
    \end{cases}
  \end{align*}
  \caption{%
    The functionality for the garbled gadget \gadget, $\func_\gadget$.
    $\func_\gadget$ computes for \E a vector of the needed seeds for her
    evaluation of the conditional circuit. For each sibling root \node of
    the active branch \aid, $\func_\gadget$ outputs the correct seed
    $s_\node$. For the remaining nodes, $\func_\gadget$ outputs
    $s'_\node$, an incorrect seed.
    %
    As presented, $\func_\gadget$ is for a complete binary tree.
    $\func_\gadget$ is easily realized as a garbled circuit.
  }\label{fig:gadget-func}
\end{figure}


\begin{figure}
  \begin{align*}
    &\evcond(\vec{\cir}, M, \vec{X}):\\
    &~~\switch~\vec{\cir}:\\
    &~~~~\ccase~(\cir):\\
    &~~~~~~\codecomment{Base case of $1$ branch.}\\
    &~~~~~~\creturn~\ev(\cir, M, \vec{X})\\
    &~~~~\ccase~(\cir_1..\cir_b):\\
    &~~~~~~\codecomment{General case of $b$ branches.}\\
    &~~~~~~\codecomment{Split material into demultiplexer and body of subtrees.}\\
    &~~~~~~(M_{dem}, M_{cond}) \gets M\\
    &~~~~~~\codecomment{Split input into the branch condition and remaining wires.}\\
    &~~~~~~S \gets \vec{X}[0]\\
    &~~~~~~\vec{X}' \gets \vec{X}[1..]\\
    &~~~~~~\codecomment{Garble both subtrees.}\\
    &~~~~~~M_0,\cdot \gets \gbcond'((\cir_1..\cir_{\frac{b}{2}}), S)\\
    &~~~~~~M_1,\cdot \gets \gbcond'((\cir_{\frac{b}{2}+1}..\cir_b), S)\\
    &~~~~~~\codecomment{Demultiplex based on the branch condition.}\\
    &~~~~~~\codecomment{One resultant vector is garbage and the other is valid.}\\
    &~~~~~~\vec{X}_0, \vec{X}_1 \gets dem.\ev(M_{dem}, S, \vec{X}')\\
    &~~~~~~Y_0 \gets \evcond((\cir_1..\cir_{\frac{b}{2}}), M \oplus M_1, \vec{X}_0)\\
    &~~~~~~Y_1 \gets \evcond((\cir_{\frac{b}{2}+1}..\cir_b), M \oplus M_0, \vec{X}_1)\\
    &~~~~~~\creturn~Y_0, Y_1
  \end{align*}
  \caption{%
    The algorithm for evaluating a conditional vector.
    Given $b$ branches, \evcond returns $b$ output label vectors.
    $b-1$ of these vectors will be garbage which must be captured by
    the multiplexer.
    One vector will be valid labels.
  }
\end{figure}
\begin{figure}
  \begin{align*}
    &\gbcond(\vec{\cir}, S):\\
    &~~\switch~\vec{\cir}:\\
    &~~~~\ccase~(\cir):\\
    &~~~~~~\codecomment{Base case of $1$ branch.}\\
    &~~~~~~M, e, d \gets \gb(\cir, S)\\
    &~~~~~~\codecomment{Return material, encoding string, decoding string, and empty garbage outputs.}\\
    &~~~~~~\creturn~M, e, d, \lambda\\
    &~~~~\ccase~(\cir_1..\cir_b):\\
    &~~~~~~\codecomment{General case of $b$ branches.}\\
    &~~~~~~\codecomment{Split material into demultiplexer and body of subtrees.}\\
    &~~~~~~e \gets \genprojection(n)\\
    &~~~~~~S^0, S^1 \gets e[0]\\
    &~~~~~~\codecomment{Garble both subtrees.}\\
    &~~~~~~M_0,e_0,d_0,junk_0 \gets \gbcond((\cir_1..\cir_{\frac{b}{2}}), S^1)\\
    &~~~~~~M_1,e_1,d_1,junk_1 \gets \gbcond((\cir_{\frac{b}{2}+1}..\cir_b), S^0)\\
    &~~~~~~\codecomment{Garble both subtrees with ``bad'' seeds.}\\
    &~~~~~~M_0',\cdot \gets \gbcond'((\cir_1..\cir_{\frac{b}{2}}), S^0)\\
    &~~~~~~M_1',\cdot \gets \gbcond'((\cir_{\frac{b}{2}+1}..\cir_b), S^1)\\
    &~~~~~~M_{dem},\bot_0, \bot_1 \gets dem.\gb(S^0, S^1, e, e_0, e_1)\\
    &~~~~~~\bot_0' \gets \evcond((\cir_1..\cir_{\frac{b}{2}}), (M_0 \oplus M_1) \oplus M_1', \bot_0)\\
    &~~~~~~\bot_1' \gets \evcond((\cir_{\frac{b}{2}+1}..\cir_b), (M_0 \oplus M_1) \oplus M_0', \bot_1)\\
    &~~~~~~\creturn~M_{dem}|(M_0\oplus M_1), e, (d_0,d_1), (junk_0,\bot_0',junk_1,\bot_1')
  \end{align*}
  \caption{%
    The algorithm for garbling a conditional vector.
    Given $b$ branches, \gbcond returns (1) the stacked material, (2)
    the input encoding string, (3) all $b$ output decoding strings,
    and (4) all $b\log b$ possible garbage output label vectors.
  }
\end{figure}

\begin{figure}
  \begin{align*}
    &\gbcond'(\vec{\cir}, S):\\
    &~~\switch~\vec{\cir}:\\
    &~~~~\ccase~(\cir):\\
    &~~~~~~\codecomment{Base case of $1$ branch.}\\
    &~~~~~~M, e, \cdot \gets \gb(\cir, S)\\
    &~~~~~~\creturn~M, e\\
    &~~~~\ccase~(\cir_1..\cir_b):\\
    &~~~~~~\codecomment{General case of $b$ branches.}\\
    &~~~~~~\codecomment{Split material into demultiplexer and body of subtrees.}\\
    &~~~~~~e \gets \genprojection(n)\\
    &~~~~~~S^0, S^1 \gets e[0]\\
    &~~~~~~\codecomment{Garble both subtrees.}\\
    &~~~~~~M_0,e_0 \gets \gbcond'((\cir_1..\cir_{\frac{b}{2}}), S^1)\\
    &~~~~~~M_1,e_1 \gets \gbcond'((\cir_{\frac{b}{2}+1}..\cir_b), S^0)\\
    &~~~~~~M_{dem},\cdot, \cdot \gets dem.\gb(S^0, S^1, e, e_0, e_1)\\
    &~~~~~~\creturn~M_{dem}|(M_0\oplus M_1), e
  \end{align*}
  \caption{%
    The helper algorithm $\gbcond'$ garbles all $b$ branches, but does
    not construct garbage material.
    Notice that $\gbcond'$ is significantly cheaper than $\gbcond$:
    $\gbcond'$ does not invoke $\evcond$ and hence has only linear
    complexity.
    This low complexity is central to our improved performance.
  }
\end{figure}






\begin{theorem}\label{thm:key}
  If $H$ is modeled as a Random Oracle, then \Cref{cnstr:ourapproach} satisfies some key property.
\end{theorem}
